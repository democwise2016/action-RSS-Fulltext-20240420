<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:itunes="http://www.itunes.com/dtds/podcast-1.0.dtd" xmlns:googleplay="http://www.google.com/schemas/play-podcasts/1.0" xmlns:media="http://www.rssboard.org/media-rss" version="2.0">
  <channel>
    <title><![CDATA[黑暗執行緒[RSS+]]]></title>
    <link>undefined</link>
    <image>
      <url>https://blog.darkthread.net/img/icon512x512.png</url>
      <title>黑暗執行緒[RSS+]</title>
      <link>undefined</link>
    </image>
    <language>en-us</language>
    <atom:link href="https://blog.darkthread.net/feed/rss/" rel="self" type="application/rss+xml"/>
    <copyright><![CDATA[黑暗執行緒[RSS+]]]></copyright>
    <itunes:author><![CDATA[黑暗執行緒[RSS+]]]></itunes:author>
    <itunes:summary>
      <![CDATA[
      黑暗執行緒部落格 - 一位在技術領域打滾多年老士官長的生活點滴<br />
<br />
<a href="https://blog.darkthread.net/feed/rss/" target="_blank">https://blog.darkthread.net/feed/rss/</a>
      ]]>
    </itunes:summary>
    <description>
      <![CDATA[
      黑暗執行緒部落格 - 一位在技術領域打滾多年老士官長的生活點滴<br />
<br />
<a href="https://blog.darkthread.net/feed/rss/" target="_blank">https://blog.darkthread.net/feed/rss/</a>
      ]]>
    </description>
    <itunes:owner>
      <itunes:name><![CDATA[黑暗執行緒[RSS+]]]></itunes:name>
    </itunes:owner>
    <itunes:image href="https://blog.darkthread.net/img/icon512x512.png"/>
<item>
    <title><![CDATA[閒聊 - 15 位高強度密碼錯了嗎？2025 年密碼該怎麼管？]]></title>
    <link>https://blog.darkthread.net/blog/15-chars-password/</link>
    <itunes:title><![CDATA[閒聊 - 15 位高強度密碼錯了嗎？2025 年密碼該怎麼管？]]></itunes:title>
    <itunes:author><![CDATA[service@darkthread.net (Jeffrey Lee)]]></itunes:author>
    <itunes:summary>
      <![CDATA[<p>這兩天有則新聞引發討論，某資安長<a href="https://www.bnext.com.tw/article/84769/asus-cyber-attack">自豪在公司推行 15 碼高強度密碼</a>，靠奇招築成駭客難以突破的鐵牆...</p> <p>還是雜誌社懂玩，下了個「強制推行15碼密碼，駭客就會"累到放手"？」的標題，「累到放手」給人「駭客坐在電腦前試密碼試到手軟」的畫面，還不忘加上問號撇清責任。貼文不意外地引發熱議，免不了引來一陣狂噴猛酸(資安長心裡苦，資安長沒法說?)。</p> <p>仔細看了內文，強推 15 碼高強度密碼為真，但發言中規中矩，沒什麼荒謬說法：</p> <blockquote> <p>其中最讓人意想不到的，就是強制推行15碼的高強度密碼。多數企業會在 IT 系統端下功夫，卻忽略了員工的個人裝置與習慣。<br> 然而，這小小的一個舉動，卻是一個「便宜」卻又非常有效的方法。<br> 密碼從 4 碼升級到 15 碼的安全強度， 就夠確保駭客在現有技術下需要花上百年才能成功破解，極大地提升了資料的安全性。<br> 「就算你把密碼貼在電腦底下，我們不鼓勵，但也會比單純4碼密碼安全的多，」<br> 「畢竟能進到公司、辦公室偷取機密的人，就已經大大減少了。」</p> </blockquote> <p>平心而論，這些論述沒有違反密碼學原理，靠密碼長度跟複雜度提升安全強度，比起買設備建系統，確實是超便宜的解決方案。</p> <p>所謂 4 碼加到 15 碼提高難度的前題，指的應該取得雜湊跑程式暴力破解的情境，而非直接線上登入嘗試，否則試不了幾次就會因出錯過多鎖帳號或擋 IP。(但一般人可能不懂二者區別)</p> <p>便利貼會外洩密碼，但確實得先突破物理限制接近辦公室，或期待使用者<a href="https://www.facebook.com/annie9527/posts/1299734260164109:488369299774301">自拍貼文</a>。估算「短密碼猜中風險」-「密碼便利貼外流風險」+「購置設備導入系統成本」，算來仍是正向投資沒錯。如果先不考慮長 15 碼又要定期換的高複雜度密碼會讓使用者「一袋米要扛幾樓」，確實是超便宜又有效的提升安全做法，簡單粗暴，對資安很簡單、對使用者很粗暴，哈!</p> <p><img src="https://blog.darkthread.net/Posts/files/2025/Fig1_638963446388367240.jpg" alt="thumbnail"></p> <p>不過，加長密碼真的沒成本嗎？其實有：</p> <ol><li>長密碼輸入耗時，影響效率 (一人多花一分鐘，兩千人的公司一上班就耗掉超過一人天了)</li> <li>長密碼容易記錯敲錯，輸錯重試耗費時間更多，若錯太多次帳號被鎖暫時無法工作，對產能的影響就更難估算了</li> <li>長密碼增加輸錯多次鎖帳號定機率，解鎖的客服人力與時間成本不容小覷</li></ol> <p>除了密碼長度，所謂高強度密碼通常還包含複雜度(大小混合、加數字、加符號)、定期變更、不能跟前幾次重複... 等，也會疊加上述三項成本。所以，高強度密碼本質是以操作繁瑣、使用不便、影響工作效率為代價去換取安全。如上次<a href="https://www.facebook.com/share/p/1Gv63EcvTp/">媒合網站個資外流議題</a>的討論， 這種「便利效率」與「安全性」的拉鋸每天都在發生，二者總是衝突的，我們一直被迫在"冒點風險 vs 便捷使用"間抉擇，決定要偏向天平的哪一邊。</p> <p>高強度密碼這件事，這些年引起一些反思。開始有人挑戰傳統思維堅持複雜度(大小寫數字符號)、定期更換、禁止重複輪替的堅持，由於資訊安全佔據道德制高點(就像國家安全、人命健康相關議題一樣)，這類討論要成功扭轉想法需要比較長的時間。</p> <p>NIST (美國國家標準暨技術研究院) 在 2004 年發佈過一版 <a href="https://csrc.nist.gov/csrc/media/publications/sp/800-63/ver-10/archive/2004-06-30/documents/sp800-63-v1-0.pdf">Electronic Authentication Guideline</a> (電子身分認證指南) 在附錄 NIST Special Publication 800-63 Appendix A 中建議電腦使用者在設定自己的密碼時，可以使用好記的簡短字眼，但必須交替使用大小寫，將部分字母替代為特殊符號，而且最好是每3個月就固定更改密碼。NIST 一直是資安領域的標竿，我們該用什麼加密演算法、憑證金鑰長度該有多長，幾乎都是 NIST 說了算，因此這份建議也成了各界奉行的圭臬，害我們定期要想一組複雜新密碼的元兇。</p> <p>不過，在 2017 年，密碼規則發明人 Bill Burr 在接受華爾街日報訪問時坦承他很後悔寫些了那些<del>鬼</del>東西，因為這套準則對一般人來說太複雜了，根本就搞錯方向。結果使用者被訓練成會設定人類想不到，對機器來說卻相對好猜的密碼，像是 Tr0ub4dor&amp;3；反觀 correcthorsebatterystaple 用四個純小寫單字組成，被機器破解的難度驟升，而對人類來說反而比較好記。(延伸閱讀：<a href="https://www.twcert.org.tw/newepaper/cp-65-670-1071e-3.html">密碼規則發明人道歉：放錯重點</a>)</p> <p>再強調一次，以上關於密碼長度與安全性的討論，指的都是駭客拿到密碼雜湊(不是密碼本身，但可以透過猜測找出密碼的一串數字)，在家泡杯茶跑暴力破解的場景，若是線上登入，一般會卡在猜錯三次鎖定、WAF 偵測封鎖 IP... 等阻礙，而網路連線存取也不可能讓你一秒鐘試幾千幾萬幾億次。</p> <p>先不考慮懶人密碼、字典攻擊，「短一寸險一寸」在密碼學的暴力破解攻擊中仍是鐵律，數學就是數學，不容質疑，之前無聊算過<a href="/blog/pwd-crack-time/">不同密碼長度與複雜度所需暴力破解時間</a>，依理論推算，用一張 4090 顯卡破解大小寫混合的 8 位密碼只需 40 分鐘，若含數字則要 2 小時，再加上符號要 3 天。若將位數提高到 15 碼，純小寫要 2440 年，大小寫混合就要近 8,000 萬年...</p> <p><img src="https://blog.darkthread.net/Posts/files/2023/Fig2_638356571420211127.png"></p> <p>幸好，NIST 在 2024 年發佈了 <a href="https://pages.nist.gov/800-63-4/sp800-63.html">SP 800-63-4 數位身份指南</a>，拋棄許多傳統上「被認為安全」但實際上對用戶不友善且效果不佳的規則。(權威果然還是靠權威來打破啊! [笑])</p> <p>依據 SP 800-63B 記憶秘密 (Memorized Secrets) 的建議：</p> <ol><li>廢除「強制定期更換密碼」：不應要求用戶定期強制使用者每 60 天或 90 天必須更換一次密。研究發現，這種要求只會導致用戶創建可預測的、微小變動的密碼（例如 Password!1 變成 Password!2），反而降低了安全性。應該只有在有證據顯示密碼已經洩露(例如在數據外洩事件中被發現)時，才應強制用戶立即更換。</li> <li>強調「長度」而非「複雜度」：不應再強制實施複雜的字符組合規則。這些規則讓密碼難以記憶，導致用戶將密碼寫在便條紙上或使用簡單的替換模式。<br> 建議做法是設定合理的最小長度(例如 8 個字元)，再強烈鼓勵並支援使用者使用更長的「密碼短語」(Passphrases)，例如一個句子，系統的密碼欄位應支援至少 64 個字元長度，並允許所有可列印的 ASCII 字元、Unicode 字元(註：這點我覺得要小心，該不會 Emoji 也行)，以及空格。</li> <li>強制檢查「已洩露密碼黑名單」：當使用者建立或更改密碼時，系統必須將該密碼與黑名單進行比對，以免駭客直接用現成已知密碼進行爆破。<br> 黑名單應包含：已知的洩露密碼(例如 Have I Been Pwned 資料庫)、字典單詞、上下文相關詞(例如服務名稱、帳號名稱等)<br> 而黑名單不僅應在建立更改密碼時檢查，還應持續監控新的外洩數據，如果發現用戶的現有密碼出現在新的外洩事件中，應立即通知用戶並強制其重設，落實「持續性洩露偵測」。</li> <li>改善用戶體驗以提升安全性：糟糕的操作體驗會導致不安全的行為，例如： - 應允許複製貼上以便利使用者使用「密碼管理軟體」管理密碼，通常這是最好保持長且複雜密碼的做法。<br> - 不應再使用「安全問題」或「密碼提示」作為恢復機制，因為像「你母親的娘家姓氏」這種問題一點都不安全。</li> <li>以速率限制取代帳戶鎖定：傳統登入失敗 3 次帳戶立即鎖定 30 分鐘或 1 小時，甚至需要聯繫客服才能解鎖，對於記性不好或易手滑的使用者極不友善，駭客甚至可藉此觸發 DoS 攻擊癱瘓系統使用。<br> NIST 建議用出錯就放慢嘗試速度的做法，例如：第 4 次失敗等待 5 秒、第 5 次失敗等 30 秒、第 6 次等五分鐘。(術語叫「指數退避」Exponential Backoff)<br> 如此限制對正常使用者還可以忍受，卻能讓駭客的暴力嘗試變得不可行。</li> <li>多因素驗證(MFA)仍是王道<br> NIST明確指出，對於需要更高安全等級(AAL2 或更高)的系統，單獨使用密碼是不可接受的，必須使用多因素驗證(MFA)，結合「What you know 你所知道的(密碼)」與「What you have 你所擁有的(例如手機 OTP、硬體安全金鑰)」或「What you are 你是誰 (生物辨識)」。</li></ol> <p>坦白說，對 NIST 的新指南，除了密碼允許所有 Unicode 字元這點，我沒想到什麼問題，而其中的思維也趨向人性化，我舉雙手贊成，以 NIST 的權威性，而這應該也是當今關於密碼長度、複雜度與應用方式的最佳依據吧，但何時會落實到我們的日常則未知。</p> <p>我很樂意改用 15 碼長密碼，只要別要求我要穿插大小寫跟符號，還強迫我 60 天改一次! 希望這天早點到來~~</p> <p data-slug="15-chars-password" data-fbimg="https://cdn.pixabay.com/photo/2015/10/27/13/05/padlocks-1009021_960_720.jpg#960#720"> </p>]]>
    </itunes:summary>
    <description>
      <![CDATA[<p>這兩天有則新聞引發討論，某資安長<a href="https://www.bnext.com.tw/article/84769/asus-cyber-attack">自豪在公司推行 15 碼高強度密碼</a>，靠奇招築成駭客難以突破的鐵牆...</p> <p>還是雜誌社懂玩，下了個「強制推行15碼密碼，駭客就會"累到放手"？」的標題，「累到放手」給人「駭客坐在電腦前試密碼試到手軟」的畫面，還不忘加上問號撇清責任。貼文不意外地引發熱議，免不了引來一陣狂噴猛酸(資安長心裡苦，資安長沒法說?)。</p> <p>仔細看了內文，強推 15 碼高強度密碼為真，但發言中規中矩，沒什麼荒謬說法：</p> <blockquote> <p>其中最讓人意想不到的，就是強制推行15碼的高強度密碼。多數企業會在 IT 系統端下功夫，卻忽略了員工的個人裝置與習慣。<br> 然而，這小小的一個舉動，卻是一個「便宜」卻又非常有效的方法。<br> 密碼從 4 碼升級到 15 碼的安全強度， 就夠確保駭客在現有技術下需要花上百年才能成功破解，極大地提升了資料的安全性。<br> 「就算你把密碼貼在電腦底下，我們不鼓勵，但也會比單純4碼密碼安全的多，」<br> 「畢竟能進到公司、辦公室偷取機密的人，就已經大大減少了。」</p> </blockquote> <p>平心而論，這些論述沒有違反密碼學原理，靠密碼長度跟複雜度提升安全強度，比起買設備建系統，確實是超便宜的解決方案。</p> <p>所謂 4 碼加到 15 碼提高難度的前題，指的應該取得雜湊跑程式暴力破解的情境，而非直接線上登入嘗試，否則試不了幾次就會因出錯過多鎖帳號或擋 IP。(但一般人可能不懂二者區別)</p> <p>便利貼會外洩密碼，但確實得先突破物理限制接近辦公室，或期待使用者<a href="https://www.facebook.com/annie9527/posts/1299734260164109:488369299774301">自拍貼文</a>。估算「短密碼猜中風險」-「密碼便利貼外流風險」+「購置設備導入系統成本」，算來仍是正向投資沒錯。如果先不考慮長 15 碼又要定期換的高複雜度密碼會讓使用者「一袋米要扛幾樓」，確實是超便宜又有效的提升安全做法，簡單粗暴，對資安很簡單、對使用者很粗暴，哈!</p> <p><img src="https://blog.darkthread.net/Posts/files/2025/Fig1_638963446388367240.jpg" alt="thumbnail"></p> <p>不過，加長密碼真的沒成本嗎？其實有：</p> <ol><li>長密碼輸入耗時，影響效率 (一人多花一分鐘，兩千人的公司一上班就耗掉超過一人天了)</li> <li>長密碼容易記錯敲錯，輸錯重試耗費時間更多，若錯太多次帳號被鎖暫時無法工作，對產能的影響就更難估算了</li> <li>長密碼增加輸錯多次鎖帳號定機率，解鎖的客服人力與時間成本不容小覷</li></ol> <p>除了密碼長度，所謂高強度密碼通常還包含複雜度(大小混合、加數字、加符號)、定期變更、不能跟前幾次重複... 等，也會疊加上述三項成本。所以，高強度密碼本質是以操作繁瑣、使用不便、影響工作效率為代價去換取安全。如上次<a href="https://www.facebook.com/share/p/1Gv63EcvTp/">媒合網站個資外流議題</a>的討論， 這種「便利效率」與「安全性」的拉鋸每天都在發生，二者總是衝突的，我們一直被迫在"冒點風險 vs 便捷使用"間抉擇，決定要偏向天平的哪一邊。</p> <p>高強度密碼這件事，這些年引起一些反思。開始有人挑戰傳統思維堅持複雜度(大小寫數字符號)、定期更換、禁止重複輪替的堅持，由於資訊安全佔據道德制高點(就像國家安全、人命健康相關議題一樣)，這類討論要成功扭轉想法需要比較長的時間。</p> <p>NIST (美國國家標準暨技術研究院) 在 2004 年發佈過一版 <a href="https://csrc.nist.gov/csrc/media/publications/sp/800-63/ver-10/archive/2004-06-30/documents/sp800-63-v1-0.pdf">Electronic Authentication Guideline</a> (電子身分認證指南) 在附錄 NIST Special Publication 800-63 Appendix A 中建議電腦使用者在設定自己的密碼時，可以使用好記的簡短字眼，但必須交替使用大小寫，將部分字母替代為特殊符號，而且最好是每3個月就固定更改密碼。NIST 一直是資安領域的標竿，我們該用什麼加密演算法、憑證金鑰長度該有多長，幾乎都是 NIST 說了算，因此這份建議也成了各界奉行的圭臬，害我們定期要想一組複雜新密碼的元兇。</p> <p>不過，在 2017 年，密碼規則發明人 Bill Burr 在接受華爾街日報訪問時坦承他很後悔寫些了那些<del>鬼</del>東西，因為這套準則對一般人來說太複雜了，根本就搞錯方向。結果使用者被訓練成會設定人類想不到，對機器來說卻相對好猜的密碼，像是 Tr0ub4dor&amp;3；反觀 correcthorsebatterystaple 用四個純小寫單字組成，被機器破解的難度驟升，而對人類來說反而比較好記。(延伸閱讀：<a href="https://www.twcert.org.tw/newepaper/cp-65-670-1071e-3.html">密碼規則發明人道歉：放錯重點</a>)</p> <p>再強調一次，以上關於密碼長度與安全性的討論，指的都是駭客拿到密碼雜湊(不是密碼本身，但可以透過猜測找出密碼的一串數字)，在家泡杯茶跑暴力破解的場景，若是線上登入，一般會卡在猜錯三次鎖定、WAF 偵測封鎖 IP... 等阻礙，而網路連線存取也不可能讓你一秒鐘試幾千幾萬幾億次。</p> <p>先不考慮懶人密碼、字典攻擊，「短一寸險一寸」在密碼學的暴力破解攻擊中仍是鐵律，數學就是數學，不容質疑，之前無聊算過<a href="/blog/pwd-crack-time/">不同密碼長度與複雜度所需暴力破解時間</a>，依理論推算，用一張 4090 顯卡破解大小寫混合的 8 位密碼只需 40 分鐘，若含數字則要 2 小時，再加上符號要 3 天。若將位數提高到 15 碼，純小寫要 2440 年，大小寫混合就要近 8,000 萬年...</p> <p><img src="https://blog.darkthread.net/Posts/files/2023/Fig2_638356571420211127.png"></p> <p>幸好，NIST 在 2024 年發佈了 <a href="https://pages.nist.gov/800-63-4/sp800-63.html">SP 800-63-4 數位身份指南</a>，拋棄許多傳統上「被認為安全」但實際上對用戶不友善且效果不佳的規則。(權威果然還是靠權威來打破啊! [笑])</p> <p>依據 SP 800-63B 記憶秘密 (Memorized Secrets) 的建議：</p> <ol><li>廢除「強制定期更換密碼」：不應要求用戶定期強制使用者每 60 天或 90 天必須更換一次密。研究發現，這種要求只會導致用戶創建可預測的、微小變動的密碼（例如 Password!1 變成 Password!2），反而降低了安全性。應該只有在有證據顯示密碼已經洩露(例如在數據外洩事件中被發現)時，才應強制用戶立即更換。</li> <li>強調「長度」而非「複雜度」：不應再強制實施複雜的字符組合規則。這些規則讓密碼難以記憶，導致用戶將密碼寫在便條紙上或使用簡單的替換模式。<br> 建議做法是設定合理的最小長度(例如 8 個字元)，再強烈鼓勵並支援使用者使用更長的「密碼短語」(Passphrases)，例如一個句子，系統的密碼欄位應支援至少 64 個字元長度，並允許所有可列印的 ASCII 字元、Unicode 字元(註：這點我覺得要小心，該不會 Emoji 也行)，以及空格。</li> <li>強制檢查「已洩露密碼黑名單」：當使用者建立或更改密碼時，系統必須將該密碼與黑名單進行比對，以免駭客直接用現成已知密碼進行爆破。<br> 黑名單應包含：已知的洩露密碼(例如 Have I Been Pwned 資料庫)、字典單詞、上下文相關詞(例如服務名稱、帳號名稱等)<br> 而黑名單不僅應在建立更改密碼時檢查，還應持續監控新的外洩數據，如果發現用戶的現有密碼出現在新的外洩事件中，應立即通知用戶並強制其重設，落實「持續性洩露偵測」。</li> <li>改善用戶體驗以提升安全性：糟糕的操作體驗會導致不安全的行為，例如： - 應允許複製貼上以便利使用者使用「密碼管理軟體」管理密碼，通常這是最好保持長且複雜密碼的做法。<br> - 不應再使用「安全問題」或「密碼提示」作為恢復機制，因為像「你母親的娘家姓氏」這種問題一點都不安全。</li> <li>以速率限制取代帳戶鎖定：傳統登入失敗 3 次帳戶立即鎖定 30 分鐘或 1 小時，甚至需要聯繫客服才能解鎖，對於記性不好或易手滑的使用者極不友善，駭客甚至可藉此觸發 DoS 攻擊癱瘓系統使用。<br> NIST 建議用出錯就放慢嘗試速度的做法，例如：第 4 次失敗等待 5 秒、第 5 次失敗等 30 秒、第 6 次等五分鐘。(術語叫「指數退避」Exponential Backoff)<br> 如此限制對正常使用者還可以忍受，卻能讓駭客的暴力嘗試變得不可行。</li> <li>多因素驗證(MFA)仍是王道<br> NIST明確指出，對於需要更高安全等級(AAL2 或更高)的系統，單獨使用密碼是不可接受的，必須使用多因素驗證(MFA)，結合「What you know 你所知道的(密碼)」與「What you have 你所擁有的(例如手機 OTP、硬體安全金鑰)」或「What you are 你是誰 (生物辨識)」。</li></ol> <p>坦白說，對 NIST 的新指南，除了密碼允許所有 Unicode 字元這點，我沒想到什麼問題，而其中的思維也趨向人性化，我舉雙手贊成，以 NIST 的權威性，而這應該也是當今關於密碼長度、複雜度與應用方式的最佳依據吧，但何時會落實到我們的日常則未知。</p> <p>我很樂意改用 15 碼長密碼，只要別要求我要穿插大小寫跟符號，還強迫我 60 天改一次! 希望這天早點到來~~</p> <p data-slug="15-chars-password" data-fbimg="https://cdn.pixabay.com/photo/2015/10/27/13/05/padlocks-1009021_960_720.jpg#960#720"> </p>]]>
    </description>
    <content:encoded><![CDATA[<p>這兩天有則新聞引發討論，某資安長<a href="https://www.bnext.com.tw/article/84769/asus-cyber-attack">自豪在公司推行 15 碼高強度密碼</a>，靠奇招築成駭客難以突破的鐵牆...</p> <p>還是雜誌社懂玩，下了個「強制推行15碼密碼，駭客就會"累到放手"？」的標題，「累到放手」給人「駭客坐在電腦前試密碼試到手軟」的畫面，還不忘加上問號撇清責任。貼文不意外地引發熱議，免不了引來一陣狂噴猛酸(資安長心裡苦，資安長沒法說?)。</p> <p>仔細看了內文，強推 15 碼高強度密碼為真，但發言中規中矩，沒什麼荒謬說法：</p> <blockquote> <p>其中最讓人意想不到的，就是強制推行15碼的高強度密碼。多數企業會在 IT 系統端下功夫，卻忽略了員工的個人裝置與習慣。<br> 然而，這小小的一個舉動，卻是一個「便宜」卻又非常有效的方法。<br> 密碼從 4 碼升級到 15 碼的安全強度， 就夠確保駭客在現有技術下需要花上百年才能成功破解，極大地提升了資料的安全性。<br> 「就算你把密碼貼在電腦底下，我們不鼓勵，但也會比單純4碼密碼安全的多，」<br> 「畢竟能進到公司、辦公室偷取機密的人，就已經大大減少了。」</p> </blockquote> <p>平心而論，這些論述沒有違反密碼學原理，靠密碼長度跟複雜度提升安全強度，比起買設備建系統，確實是超便宜的解決方案。</p> <p>所謂 4 碼加到 15 碼提高難度的前題，指的應該取得雜湊跑程式暴力破解的情境，而非直接線上登入嘗試，否則試不了幾次就會因出錯過多鎖帳號或擋 IP。(但一般人可能不懂二者區別)</p> <p>便利貼會外洩密碼，但確實得先突破物理限制接近辦公室，或期待使用者<a href="https://www.facebook.com/annie9527/posts/1299734260164109:488369299774301">自拍貼文</a>。估算「短密碼猜中風險」-「密碼便利貼外流風險」+「購置設備導入系統成本」，算來仍是正向投資沒錯。如果先不考慮長 15 碼又要定期換的高複雜度密碼會讓使用者「一袋米要扛幾樓」，確實是超便宜又有效的提升安全做法，簡單粗暴，對資安很簡單、對使用者很粗暴，哈!</p> <p><img src="https://blog.darkthread.net/Posts/files/2025/Fig1_638963446388367240.jpg" alt="thumbnail"></p> <p>不過，加長密碼真的沒成本嗎？其實有：</p> <ol><li>長密碼輸入耗時，影響效率 (一人多花一分鐘，兩千人的公司一上班就耗掉超過一人天了)</li> <li>長密碼容易記錯敲錯，輸錯重試耗費時間更多，若錯太多次帳號被鎖暫時無法工作，對產能的影響就更難估算了</li> <li>長密碼增加輸錯多次鎖帳號定機率，解鎖的客服人力與時間成本不容小覷</li></ol> <p>除了密碼長度，所謂高強度密碼通常還包含複雜度(大小混合、加數字、加符號)、定期變更、不能跟前幾次重複... 等，也會疊加上述三項成本。所以，高強度密碼本質是以操作繁瑣、使用不便、影響工作效率為代價去換取安全。如上次<a href="https://www.facebook.com/share/p/1Gv63EcvTp/">媒合網站個資外流議題</a>的討論， 這種「便利效率」與「安全性」的拉鋸每天都在發生，二者總是衝突的，我們一直被迫在"冒點風險 vs 便捷使用"間抉擇，決定要偏向天平的哪一邊。</p> <p>高強度密碼這件事，這些年引起一些反思。開始有人挑戰傳統思維堅持複雜度(大小寫數字符號)、定期更換、禁止重複輪替的堅持，由於資訊安全佔據道德制高點(就像國家安全、人命健康相關議題一樣)，這類討論要成功扭轉想法需要比較長的時間。</p> <p>NIST (美國國家標準暨技術研究院) 在 2004 年發佈過一版 <a href="https://csrc.nist.gov/csrc/media/publications/sp/800-63/ver-10/archive/2004-06-30/documents/sp800-63-v1-0.pdf">Electronic Authentication Guideline</a> (電子身分認證指南) 在附錄 NIST Special Publication 800-63 Appendix A 中建議電腦使用者在設定自己的密碼時，可以使用好記的簡短字眼，但必須交替使用大小寫，將部分字母替代為特殊符號，而且最好是每3個月就固定更改密碼。NIST 一直是資安領域的標竿，我們該用什麼加密演算法、憑證金鑰長度該有多長，幾乎都是 NIST 說了算，因此這份建議也成了各界奉行的圭臬，害我們定期要想一組複雜新密碼的元兇。</p> <p>不過，在 2017 年，密碼規則發明人 Bill Burr 在接受華爾街日報訪問時坦承他很後悔寫些了那些<del>鬼</del>東西，因為這套準則對一般人來說太複雜了，根本就搞錯方向。結果使用者被訓練成會設定人類想不到，對機器來說卻相對好猜的密碼，像是 Tr0ub4dor&amp;3；反觀 correcthorsebatterystaple 用四個純小寫單字組成，被機器破解的難度驟升，而對人類來說反而比較好記。(延伸閱讀：<a href="https://www.twcert.org.tw/newepaper/cp-65-670-1071e-3.html">密碼規則發明人道歉：放錯重點</a>)</p> <p>再強調一次，以上關於密碼長度與安全性的討論，指的都是駭客拿到密碼雜湊(不是密碼本身，但可以透過猜測找出密碼的一串數字)，在家泡杯茶跑暴力破解的場景，若是線上登入，一般會卡在猜錯三次鎖定、WAF 偵測封鎖 IP... 等阻礙，而網路連線存取也不可能讓你一秒鐘試幾千幾萬幾億次。</p> <p>先不考慮懶人密碼、字典攻擊，「短一寸險一寸」在密碼學的暴力破解攻擊中仍是鐵律，數學就是數學，不容質疑，之前無聊算過<a href="/blog/pwd-crack-time/">不同密碼長度與複雜度所需暴力破解時間</a>，依理論推算，用一張 4090 顯卡破解大小寫混合的 8 位密碼只需 40 分鐘，若含數字則要 2 小時，再加上符號要 3 天。若將位數提高到 15 碼，純小寫要 2440 年，大小寫混合就要近 8,000 萬年...</p> <p><img src="https://blog.darkthread.net/Posts/files/2023/Fig2_638356571420211127.png"></p> <p>幸好，NIST 在 2024 年發佈了 <a href="https://pages.nist.gov/800-63-4/sp800-63.html">SP 800-63-4 數位身份指南</a>，拋棄許多傳統上「被認為安全」但實際上對用戶不友善且效果不佳的規則。(權威果然還是靠權威來打破啊! [笑])</p> <p>依據 SP 800-63B 記憶秘密 (Memorized Secrets) 的建議：</p> <ol><li>廢除「強制定期更換密碼」：不應要求用戶定期強制使用者每 60 天或 90 天必須更換一次密。研究發現，這種要求只會導致用戶創建可預測的、微小變動的密碼（例如 Password!1 變成 Password!2），反而降低了安全性。應該只有在有證據顯示密碼已經洩露(例如在數據外洩事件中被發現)時，才應強制用戶立即更換。</li> <li>強調「長度」而非「複雜度」：不應再強制實施複雜的字符組合規則。這些規則讓密碼難以記憶，導致用戶將密碼寫在便條紙上或使用簡單的替換模式。<br> 建議做法是設定合理的最小長度(例如 8 個字元)，再強烈鼓勵並支援使用者使用更長的「密碼短語」(Passphrases)，例如一個句子，系統的密碼欄位應支援至少 64 個字元長度，並允許所有可列印的 ASCII 字元、Unicode 字元(註：這點我覺得要小心，該不會 Emoji 也行)，以及空格。</li> <li>強制檢查「已洩露密碼黑名單」：當使用者建立或更改密碼時，系統必須將該密碼與黑名單進行比對，以免駭客直接用現成已知密碼進行爆破。<br> 黑名單應包含：已知的洩露密碼(例如 Have I Been Pwned 資料庫)、字典單詞、上下文相關詞(例如服務名稱、帳號名稱等)<br> 而黑名單不僅應在建立更改密碼時檢查，還應持續監控新的外洩數據，如果發現用戶的現有密碼出現在新的外洩事件中，應立即通知用戶並強制其重設，落實「持續性洩露偵測」。</li> <li>改善用戶體驗以提升安全性：糟糕的操作體驗會導致不安全的行為，例如： - 應允許複製貼上以便利使用者使用「密碼管理軟體」管理密碼，通常這是最好保持長且複雜密碼的做法。<br> - 不應再使用「安全問題」或「密碼提示」作為恢復機制，因為像「你母親的娘家姓氏」這種問題一點都不安全。</li> <li>以速率限制取代帳戶鎖定：傳統登入失敗 3 次帳戶立即鎖定 30 分鐘或 1 小時，甚至需要聯繫客服才能解鎖，對於記性不好或易手滑的使用者極不友善，駭客甚至可藉此觸發 DoS 攻擊癱瘓系統使用。<br> NIST 建議用出錯就放慢嘗試速度的做法，例如：第 4 次失敗等待 5 秒、第 5 次失敗等 30 秒、第 6 次等五分鐘。(術語叫「指數退避」Exponential Backoff)<br> 如此限制對正常使用者還可以忍受，卻能讓駭客的暴力嘗試變得不可行。</li> <li>多因素驗證(MFA)仍是王道<br> NIST明確指出，對於需要更高安全等級(AAL2 或更高)的系統，單獨使用密碼是不可接受的，必須使用多因素驗證(MFA)，結合「What you know 你所知道的(密碼)」與「What you have 你所擁有的(例如手機 OTP、硬體安全金鑰)」或「What you are 你是誰 (生物辨識)」。</li></ol> <p>坦白說，對 NIST 的新指南，除了密碼允許所有 Unicode 字元這點，我沒想到什麼問題，而其中的思維也趨向人性化，我舉雙手贊成，以 NIST 的權威性，而這應該也是當今關於密碼長度、複雜度與應用方式的最佳依據吧，但何時會落實到我們的日常則未知。</p> <p>我很樂意改用 15 碼長密碼，只要別要求我要穿插大小寫跟符號，還強迫我 60 天改一次! 希望這天早點到來~~</p> <p data-slug="15-chars-password" data-fbimg="https://cdn.pixabay.com/photo/2015/10/27/13/05/padlocks-1009021_960_720.jpg#960#720"> </p>]]></content:encoded>
    <itunes:image href="https://blog.darkthread.net/Posts/files/2025/Fig1_638963446388367240.jpg"/>
          <media:content url="https://blog.darkthread.net/Posts/files/2025/Fig1_638963446388367240.jpg" medium="image"/>
    <pubDate>Sat, 18 Oct 2025 00:35:30 GMT</pubDate>
  </item><item>
    <title><![CDATA[嚴重等級 9.9 的 ASP.NET Core 資安漏洞 CVE-2025-55315]]></title>
    <link>https://blog.darkthread.net/blog/cve-2025-55315/</link>
    <itunes:title><![CDATA[嚴重等級 9.9 的 ASP.NET Core 資安漏洞 CVE-2025-55315]]></itunes:title>
    <itunes:author><![CDATA[service@darkthread.net (Jeffrey Lee)]]></itunes:author>
    <itunes:summary>
      <![CDATA[<p>微軟在 10/14 發佈了一則<a href="https://msrc.microsoft.com/update-guide/vulnerability/CVE-2025-55315?WT.mc_id=DOP-MVP-37580">資安漏洞公告 CVE-2025-55315</a>，其 CVSS (Common Vulnerability Scoring System) 漏洞嚴重等級直上 9.9、危險等級也高達 8.6。</p> <p>起源是 ASP.NET Core 從 2.3 到 .NET 10 的 Kestrel 都存在一個安全漏洞，由於 Kestrel 對 HTTP Request Header 的檢查邏輯不夠周全，攻擊者有可能透過特殊設計的 HTTP 請求資料，由看似正常的請求挾帶惡意請求繞過安全檢查成功闖關。(這種手法又稱為 <a href="https://cwe.mitre.org/data/definitions/444.html">HTTP Request/Response Smuggling 走私</a>)</p> <p>一旦闖關成功，視應用程式的設計方式不同，攻擊者有機會略過權限管控、取得使用者登入憑證、竊取機密資料、竄改檔案內容、形成 DoS 攻擊... 等，雖然成功前題與系統設計有關，而這些對應到 CVSS 評分的機密性(C)、完整性(I)、可用性(A)，考量最壞的狀況，都可視為高風險，讓嚴重度升高到 9.9。</p> <p>【資安科普】CVSS 的嚴重性 Critical 分數通常對應一個最直接、最容易被利用的攻擊情境，一個 9.9 分的漏洞通常具備以下特徵：</p> <ul><li>攻擊向量 (AV): 網路 (Network) - 駭客可以從遠端透過網路發動攻擊。</li> <li>攻擊複雜度 (AC): 低 (Low) - 不需要複雜的條件或技術即可成功利用。</li> <li>所需權限 (PR): 無 (None) - 駭客不需要任何權限就能攻擊。</li> <li>使用者互動 (UI): 無 (None) - 不需要使用者執行任何動作。</li> <li>範疇 (S): 已變更 (Changed) - 漏洞的影響會超越原本的軟體元件，可能影響到整個作業系統。</li> <li>機密性 (C)、完整性 (I)、可用性 (A) 影響: 皆為高 (High) - 能讓駭客竊取所有資料、竄改任何檔案，並讓系統完全癱瘓。</li></ul> <p>考慮最壞的狀況，攻擊者可以不需要密碼、不需要使用者點擊任何東西，就能從網際網路連上有漏洞的 ASP.NET Core Ketrel，偷資料改檔案並癱瘓整台伺服器，符合 9.9 標準。</p> <p>(但依據 Microsoft 安全專家 Kevin Dorrans 的說法：給這個漏洞打最高分，是基於「最壞情況」的假設。這個最壞情況就是：攻擊者不僅能繞過安全機制，還能影響到系統的其他部分。但說實話，這種最壞情況發生的機率很低，除非你的程式碼夠低級，省掉原本該有的基本安全檢查。<a href="https://www.securityweek.com/highest-ever-severity-score-assigned-by-microsoft-to-asp-net-core-vulnerability/amp/">參考</a>)</p> <p>至於修補方式，依 ASP.NET Core 版本不同，做法不同。</p> <ul><li>若為 .NET 8 或更新版本，請從 Microsoft Update 安裝 .NET 更新，然後重新啟動應用程式或重新啟動電腦即可。</li> <li>若為 ASP.NET Core 2.3，則必須更新 Microsoft.AspNet.Server.Kestrel.Core 套件到 2.3.6，然後重新編譯您的應用程式並重新部署。</li> <li>若程式被編譯為獨立/單一檔案應用程式(--self-contained)，則必須更新 .NET 版本、重新編譯應用程式並重新部署。</li></ul> <p>如何檢查目前的 .NET 版本是否安全？最簡單的做法是執行 <code>dotent --info</code>，檢查 Microsoft.AspNetCore.App 的版本：</p> <p><img src="https://blog.darkthread.net/Posts/files/2025/Fig1_638963087608043617.png"></p> <p>(註：若是用 Docker 跑 ASP.NET Core，理論上重新編譯 Image 就會從 mcr.microsoft.com/dotnet/aspnet:X.0 抓最新版本，不放心的話可用 <code>docker exec -it &lt;container-name&gt; /bin/bash</code> 登入，再用 <code>dotnet --info</code> 檢查。延伸閱讀：<a href="/blog/docker-cli-tips/">Docker 排查偵錯常用 CLI 指令整理</a>)</p> <p>依 ASP.NET Core 版本，版本需升級到 2.3.6、8.0.21、9.0.10 以上。Visual Studio 2022 的部分，需更新到 17.10.20、17.12.13、17.14.17 以上。<a href="https://msrc.microsoft.com/update-guide/vulnerability/CVE-2025-55315?WT.mc_id=DOP-MVP-37580">參考</a></p> <p data-slug="cve-2025-55315" data-title-en="ASP.NET Security Feature Bypass Vulnerability CVE-2025-55315" data-catg=".NET" data-fbimg="https://i.postimg.cc/44h0G00X/Generated-Image-October-17-2025-10-34-PM.png#1280#731">CVE-2025-53315 affects ASP.NET Core Kestrel, allowing severe remote attacks; update .NET and related components to secure your system.</p>]]>
    </itunes:summary>
    <description>
      <![CDATA[<p>微軟在 10/14 發佈了一則<a href="https://msrc.microsoft.com/update-guide/vulnerability/CVE-2025-55315?WT.mc_id=DOP-MVP-37580">資安漏洞公告 CVE-2025-55315</a>，其 CVSS (Common Vulnerability Scoring System) 漏洞嚴重等級直上 9.9、危險等級也高達 8.6。</p> <p>起源是 ASP.NET Core 從 2.3 到 .NET 10 的 Kestrel 都存在一個安全漏洞，由於 Kestrel 對 HTTP Request Header 的檢查邏輯不夠周全，攻擊者有可能透過特殊設計的 HTTP 請求資料，由看似正常的請求挾帶惡意請求繞過安全檢查成功闖關。(這種手法又稱為 <a href="https://cwe.mitre.org/data/definitions/444.html">HTTP Request/Response Smuggling 走私</a>)</p> <p>一旦闖關成功，視應用程式的設計方式不同，攻擊者有機會略過權限管控、取得使用者登入憑證、竊取機密資料、竄改檔案內容、形成 DoS 攻擊... 等，雖然成功前題與系統設計有關，而這些對應到 CVSS 評分的機密性(C)、完整性(I)、可用性(A)，考量最壞的狀況，都可視為高風險，讓嚴重度升高到 9.9。</p> <p>【資安科普】CVSS 的嚴重性 Critical 分數通常對應一個最直接、最容易被利用的攻擊情境，一個 9.9 分的漏洞通常具備以下特徵：</p> <ul><li>攻擊向量 (AV): 網路 (Network) - 駭客可以從遠端透過網路發動攻擊。</li> <li>攻擊複雜度 (AC): 低 (Low) - 不需要複雜的條件或技術即可成功利用。</li> <li>所需權限 (PR): 無 (None) - 駭客不需要任何權限就能攻擊。</li> <li>使用者互動 (UI): 無 (None) - 不需要使用者執行任何動作。</li> <li>範疇 (S): 已變更 (Changed) - 漏洞的影響會超越原本的軟體元件，可能影響到整個作業系統。</li> <li>機密性 (C)、完整性 (I)、可用性 (A) 影響: 皆為高 (High) - 能讓駭客竊取所有資料、竄改任何檔案，並讓系統完全癱瘓。</li></ul> <p>考慮最壞的狀況，攻擊者可以不需要密碼、不需要使用者點擊任何東西，就能從網際網路連上有漏洞的 ASP.NET Core Ketrel，偷資料改檔案並癱瘓整台伺服器，符合 9.9 標準。</p> <p>(但依據 Microsoft 安全專家 Kevin Dorrans 的說法：給這個漏洞打最高分，是基於「最壞情況」的假設。這個最壞情況就是：攻擊者不僅能繞過安全機制，還能影響到系統的其他部分。但說實話，這種最壞情況發生的機率很低，除非你的程式碼夠低級，省掉原本該有的基本安全檢查。<a href="https://www.securityweek.com/highest-ever-severity-score-assigned-by-microsoft-to-asp-net-core-vulnerability/amp/">參考</a>)</p> <p>至於修補方式，依 ASP.NET Core 版本不同，做法不同。</p> <ul><li>若為 .NET 8 或更新版本，請從 Microsoft Update 安裝 .NET 更新，然後重新啟動應用程式或重新啟動電腦即可。</li> <li>若為 ASP.NET Core 2.3，則必須更新 Microsoft.AspNet.Server.Kestrel.Core 套件到 2.3.6，然後重新編譯您的應用程式並重新部署。</li> <li>若程式被編譯為獨立/單一檔案應用程式(--self-contained)，則必須更新 .NET 版本、重新編譯應用程式並重新部署。</li></ul> <p>如何檢查目前的 .NET 版本是否安全？最簡單的做法是執行 <code>dotent --info</code>，檢查 Microsoft.AspNetCore.App 的版本：</p> <p><img src="https://blog.darkthread.net/Posts/files/2025/Fig1_638963087608043617.png"></p> <p>(註：若是用 Docker 跑 ASP.NET Core，理論上重新編譯 Image 就會從 mcr.microsoft.com/dotnet/aspnet:X.0 抓最新版本，不放心的話可用 <code>docker exec -it &lt;container-name&gt; /bin/bash</code> 登入，再用 <code>dotnet --info</code> 檢查。延伸閱讀：<a href="/blog/docker-cli-tips/">Docker 排查偵錯常用 CLI 指令整理</a>)</p> <p>依 ASP.NET Core 版本，版本需升級到 2.3.6、8.0.21、9.0.10 以上。Visual Studio 2022 的部分，需更新到 17.10.20、17.12.13、17.14.17 以上。<a href="https://msrc.microsoft.com/update-guide/vulnerability/CVE-2025-55315?WT.mc_id=DOP-MVP-37580">參考</a></p> <p data-slug="cve-2025-55315" data-title-en="ASP.NET Security Feature Bypass Vulnerability CVE-2025-55315" data-catg=".NET" data-fbimg="https://i.postimg.cc/44h0G00X/Generated-Image-October-17-2025-10-34-PM.png#1280#731">CVE-2025-53315 affects ASP.NET Core Kestrel, allowing severe remote attacks; update .NET and related components to secure your system.</p>]]>
    </description>
    <content:encoded><![CDATA[<p>微軟在 10/14 發佈了一則<a href="https://msrc.microsoft.com/update-guide/vulnerability/CVE-2025-55315?WT.mc_id=DOP-MVP-37580">資安漏洞公告 CVE-2025-55315</a>，其 CVSS (Common Vulnerability Scoring System) 漏洞嚴重等級直上 9.9、危險等級也高達 8.6。</p> <p>起源是 ASP.NET Core 從 2.3 到 .NET 10 的 Kestrel 都存在一個安全漏洞，由於 Kestrel 對 HTTP Request Header 的檢查邏輯不夠周全，攻擊者有可能透過特殊設計的 HTTP 請求資料，由看似正常的請求挾帶惡意請求繞過安全檢查成功闖關。(這種手法又稱為 <a href="https://cwe.mitre.org/data/definitions/444.html">HTTP Request/Response Smuggling 走私</a>)</p> <p>一旦闖關成功，視應用程式的設計方式不同，攻擊者有機會略過權限管控、取得使用者登入憑證、竊取機密資料、竄改檔案內容、形成 DoS 攻擊... 等，雖然成功前題與系統設計有關，而這些對應到 CVSS 評分的機密性(C)、完整性(I)、可用性(A)，考量最壞的狀況，都可視為高風險，讓嚴重度升高到 9.9。</p> <p>【資安科普】CVSS 的嚴重性 Critical 分數通常對應一個最直接、最容易被利用的攻擊情境，一個 9.9 分的漏洞通常具備以下特徵：</p> <ul><li>攻擊向量 (AV): 網路 (Network) - 駭客可以從遠端透過網路發動攻擊。</li> <li>攻擊複雜度 (AC): 低 (Low) - 不需要複雜的條件或技術即可成功利用。</li> <li>所需權限 (PR): 無 (None) - 駭客不需要任何權限就能攻擊。</li> <li>使用者互動 (UI): 無 (None) - 不需要使用者執行任何動作。</li> <li>範疇 (S): 已變更 (Changed) - 漏洞的影響會超越原本的軟體元件，可能影響到整個作業系統。</li> <li>機密性 (C)、完整性 (I)、可用性 (A) 影響: 皆為高 (High) - 能讓駭客竊取所有資料、竄改任何檔案，並讓系統完全癱瘓。</li></ul> <p>考慮最壞的狀況，攻擊者可以不需要密碼、不需要使用者點擊任何東西，就能從網際網路連上有漏洞的 ASP.NET Core Ketrel，偷資料改檔案並癱瘓整台伺服器，符合 9.9 標準。</p> <p>(但依據 Microsoft 安全專家 Kevin Dorrans 的說法：給這個漏洞打最高分，是基於「最壞情況」的假設。這個最壞情況就是：攻擊者不僅能繞過安全機制，還能影響到系統的其他部分。但說實話，這種最壞情況發生的機率很低，除非你的程式碼夠低級，省掉原本該有的基本安全檢查。<a href="https://www.securityweek.com/highest-ever-severity-score-assigned-by-microsoft-to-asp-net-core-vulnerability/amp/">參考</a>)</p> <p>至於修補方式，依 ASP.NET Core 版本不同，做法不同。</p> <ul><li>若為 .NET 8 或更新版本，請從 Microsoft Update 安裝 .NET 更新，然後重新啟動應用程式或重新啟動電腦即可。</li> <li>若為 ASP.NET Core 2.3，則必須更新 Microsoft.AspNet.Server.Kestrel.Core 套件到 2.3.6，然後重新編譯您的應用程式並重新部署。</li> <li>若程式被編譯為獨立/單一檔案應用程式(--self-contained)，則必須更新 .NET 版本、重新編譯應用程式並重新部署。</li></ul> <p>如何檢查目前的 .NET 版本是否安全？最簡單的做法是執行 <code>dotent --info</code>，檢查 Microsoft.AspNetCore.App 的版本：</p> <p><img src="https://blog.darkthread.net/Posts/files/2025/Fig1_638963087608043617.png"></p> <p>(註：若是用 Docker 跑 ASP.NET Core，理論上重新編譯 Image 就會從 mcr.microsoft.com/dotnet/aspnet:X.0 抓最新版本，不放心的話可用 <code>docker exec -it &lt;container-name&gt; /bin/bash</code> 登入，再用 <code>dotnet --info</code> 檢查。延伸閱讀：<a href="/blog/docker-cli-tips/">Docker 排查偵錯常用 CLI 指令整理</a>)</p> <p>依 ASP.NET Core 版本，版本需升級到 2.3.6、8.0.21、9.0.10 以上。Visual Studio 2022 的部分，需更新到 17.10.20、17.12.13、17.14.17 以上。<a href="https://msrc.microsoft.com/update-guide/vulnerability/CVE-2025-55315?WT.mc_id=DOP-MVP-37580">參考</a></p> <p data-slug="cve-2025-55315" data-title-en="ASP.NET Security Feature Bypass Vulnerability CVE-2025-55315" data-catg=".NET" data-fbimg="https://i.postimg.cc/44h0G00X/Generated-Image-October-17-2025-10-34-PM.png#1280#731">CVE-2025-53315 affects ASP.NET Core Kestrel, allowing severe remote attacks; update .NET and related components to secure your system.</p>]]></content:encoded>
    <itunes:image href="https://blog.darkthread.net/Posts/files/2025/Fig1_638963087608043617.png"/>
          <media:content url="https://blog.darkthread.net/Posts/files/2025/Fig1_638963087608043617.png" medium="image"/>
    <pubDate>Fri, 17 Oct 2025 14:38:22 GMT</pubDate>
  </item><item>
    <title><![CDATA[7-Zip 安全漏洞通報與版本盤點工具]]></title>
    <link>https://blog.darkthread.net/blog/7z-vulnerabilities-n-scan-tool/</link>
    <itunes:title><![CDATA[7-Zip 安全漏洞通報與版本盤點工具]]></itunes:title>
    <itunes:author><![CDATA[service@darkthread.net (Jeffrey Lee)]]></itunes:author>
    <itunes:summary>
      <![CDATA[<p>7-Zip 最近<a href="https://www.facebook.com/will.fans/posts/7-zip-%E5%A3%93%E7%B8%AE%E5%B7%A5%E5%85%B7%E7%99%BC%E7%8F%BE%E5%85%A9%E5%80%8B-cvss-score-%E9%AB%98%E9%81%94-7-%E5%88%86%E7%9A%84-cve-2025-11001-%E8%88%87-cve-2025-11002-%E6%BC%8F%E6%B4%9E-7-zip-%E4%B8%AD%E5%AD%98%E5%9C%A8%E4%B8%80%E5%80%8B/1249133997240687/">被發現兩個安全漏洞：CVE-2025-11001 及 CVE-2025-11002</a>，問題源於 7-Zip 解壓縮時對符號連結（Symbolic Link）與目錄穿越（Directory Traversal）的處理邏輯不夠周全，導致攻擊者可在 ZIP 檔刻意放入特殊的符號連結以「繞出」預期目錄，將惡意檔案覆蓋或寫入到系統敏感位置。一個可行的攻擊途徑是攻擊者設法將惡意 ZIP 檔送到使用者手上並誘騙其進行解壓縮，藉由漏洞將系統服務或使用者常用執行檔換成植入惡意程式的版本，一但加料版被執行即可完成攻擊。<br> 延伸閱讀：</p> <ul><li><a href="https://cybersecuritynews.com/7-zip-vulnerabilities/">7-Zip Vulnerabilities Let Attackers Execute Arbitrary Code Remotely</a></li></ul> <p>7-Zip 的<a href="https://github.com/ip7z/7zip/releases/tag/25.01">最新版本 25.01</a>已修正這個兩個漏洞，建議大家盡快更新。<br> (題外話：以 7-Zip 的輕巧穩定，執行速度快，功能又完整，Windows 真該把它收為內建工具並自動更新。)</p> <p>為確保修補作業沒有遺漏，我決定寫個 PowerShell 腳本掃瞄資料夾，找出所有 7z.exe/7z.dll 並檢查版本，確保都有更新到最新版。</p> <pre><code>param (
[Parameter(Mandatory = $true)]
[string]$Path,
[string]$CsvPath
)
function CheckVersion($filePath) {
$version = '?'
try {
$version = (Get-Item $filePath).VersionInfo.ProductVersion
$majorVersion = [int]::Parse($version.Split('.')[0])
$passed = $majorVersion -ge 25
$status = if ($passed) { "PASS" } else { "FAIL" }
}
catch {
$status = "ERROR"
}
return [PSCustomObject]@{
Path    = $filePath
Version = $version
Status  = $status
}
}
function ShowResult($result) {
$color = if ($result.Status -eq 'PASS') { 'Green' } elseif ($result.Status -eq 'FAIL') { 'Red' } else { 'Cyan' }
Write-Host "$($result.Status)`t$($result.Version)`t$($result.Path)" -ForegroundColor $color
}
$gciErrors = $null
# -File to ensure we only get files, not directories
# -Force to include hidden/system directories/files
# -ErrorAction SilentlyContinue to suppress errors (e.g., access denied)
# -ErrorVariable gciErrors to capture any errors for later reporting
$results = @()
if ($Path.EndsWith('.csv')) {
$csvPaths = @()
try {
$csvPaths = Import-Csv -Path $Path | ForEach-Object { $_.Path } | Where-Object { Test-Path $_ }
}
catch {
Write-Host "Error reading CSV file: $_" -ForegroundColor Red
exit 1
}
Write-Host "Verifying paths from [$Path]..." -ForegroundColor Yellow
foreach ($csvPath in $csvPaths) {
if (Test-Path $csvPath) {
$result = CheckVersion -filePath $csvPath
ShowResult -result $result
$results += $result
}
else {
$reulst = ([PSCustomObject]@{
Path    = $csvPath
Version = '?'
Status  = '404'
})
ShowResult -result $result
$results += $result
}
}
$CsvPath = $Path
Write-Host "`nUpdating results to [$CsvPath]..." -ForegroundColor Yellow
$results | Export-Csv -Path $CsvPath -NoTypeInformation -Encoding UTF8
}
else {
$sw = [System.Diagnostics.Stopwatch]::StartNew()
Write-Host "Scanning path [$Path] for 7z.exe and 7z.dll files..." -ForegroundColor Yellow
$sw.Start()
Get-ChildItem -Path $Path -Recurse -Filter '7z.*' -File -Force -ErrorAction SilentlyContinue -ErrorVariable gciErrors |
Where-Object { $_.Name -ieq '7z.exe' -or $_.Name -like '7z.dll' } |
ForEach-Object {
$result = CheckVersion -filePath $_.FullName
ShowResult -result $result
$results += $result
}
$sw.Stop()
Write-Host "`nScan completed in $($sw.Elapsed.TotalSeconds.ToString('n0')) seconds." -ForegroundColor Yellow
# Generate default output CSV path
if (-not $CsvPath) {
$CsvPath = Join-Path -Path (Get-Location) -ChildPath "7zip_Scan_$(Get-Date -Format 'yyyyMMdd_HHmmss').csv"
}
Write-Host "`nExporting results to [$CsvPath]..." -ForegroundColor Yellow
$results | Export-Csv -Path $CsvPath -NoTypeInformation -Encoding UTF8
if ($gciErrors) {
$displayErrors = Read-Host "`n$($gciErrors.Count) IO Errors, display? (Y/N)"
if ($displayErrors -ieq 'Y') {
$sb = New-Object -TypeName System.Text.StringBuilder
foreach ($err in $gciErrors) {
$sb.AppendLine($err.Exception.Message) | Out-Null
}
$tempPath = [System.IO.Path]::GetTempFileName() + ".txt"
$sb.ToString() | Out-File -FilePath $tempPath -Encoding UTF8
Start-Process -FilePath $tempPath
}
}
}
</code></pre> <p>使用方法很簡單 <code>Atk-Scan7zipVersion.ps1 D:\</code> 即可找出 D 槽所有的 7z.exe 及 7z.dll 的版本，大於 25.X 的顯示綠色，否則紅色 (無法判斷版號顯示灰色，理論上不會發生)，並將結果存成 CSV。CSV 檔會依日期時間自動命名，或者也可自行指定，例如：<code>Atk-Scan7zipVersion.ps1 D:\ -CsvPath E:\results.csv</code>。</p> <p><img src="https://blog.darkthread.net/Posts/files/2025/Fig1_638961338754718290.png"></p> <p>掃瞄時建議使用管理者權限，但實務上仍可能有些系統目錄會無法存取或找不到路徑，這類存取錯誤訊息會另存暫時目錄，若有需要可以查看。</p> <p>如圖所示，掃瞄一次可能耗時數分鐘，掃瞄結果會存成 CSV 方便後續修補及複核版本是否更新完成。</p> <p><img src="https://blog.darkthread.net/Posts/files/2025/Fig3_638961338756548573.png"></p> <p>如要複核版本狀態，可帶入 CSV 路徑，直接依據清單上的路徑逐一檢查，並將結果更新回 CSV 檔，如此可省下重新掃瞄的時間，在幾秒內完成，。</p> <p><img src="https://blog.darkthread.net/Posts/files/2025/Fig2_638961338758944660.png"></p> <p>至於修補原則，實際掃瞄會發現很多軟體都依賴 7z.exe 解壓縮，例如範例中的 Chocolatey、Visual Studio Xamarin 擴充套件... 等，這類 7z.exe 解壓對象多侷限應用程式自身的套件、更新檔等，不會被用來解壓其他檔案。由於這次的攻擊需使用者互動（如開啟特定惡意 ZIP 檔）才能完成，故風險較高的是使用者日常使用的 7-Zip 程式，至於這類軟體自帶的 7z 程式或程式庫，要被拿來作惡不是那麼容易(BUT，資安有張無敵鬼牌：萬一萬一又萬一)，加上強制置換軟體所屬檔案可能會有副作用，要不要也都更新？就留給大家自行拿捏了。</p> <p data-slug="7z-vulnerabilities-n-scan-tool" data-title-en="7-Zip vulnerabilities warning and version scan tool by PowerShell" data-catg=".NET" data-fbimg="https://cdn.pixabay.com/photo/2023/09/25/20/04/fire-alarm-8275941_1280.jpg#1280#720">Discusses 7-Zip vulnerabilities and shares a PowerShell script to scan, verify, and update 7z.exe/7z.dll versions for enhanced security.</p>]]>
    </itunes:summary>
    <description>
      <![CDATA[<p>7-Zip 最近<a href="https://www.facebook.com/will.fans/posts/7-zip-%E5%A3%93%E7%B8%AE%E5%B7%A5%E5%85%B7%E7%99%BC%E7%8F%BE%E5%85%A9%E5%80%8B-cvss-score-%E9%AB%98%E9%81%94-7-%E5%88%86%E7%9A%84-cve-2025-11001-%E8%88%87-cve-2025-11002-%E6%BC%8F%E6%B4%9E-7-zip-%E4%B8%AD%E5%AD%98%E5%9C%A8%E4%B8%80%E5%80%8B/1249133997240687/">被發現兩個安全漏洞：CVE-2025-11001 及 CVE-2025-11002</a>，問題源於 7-Zip 解壓縮時對符號連結（Symbolic Link）與目錄穿越（Directory Traversal）的處理邏輯不夠周全，導致攻擊者可在 ZIP 檔刻意放入特殊的符號連結以「繞出」預期目錄，將惡意檔案覆蓋或寫入到系統敏感位置。一個可行的攻擊途徑是攻擊者設法將惡意 ZIP 檔送到使用者手上並誘騙其進行解壓縮，藉由漏洞將系統服務或使用者常用執行檔換成植入惡意程式的版本，一但加料版被執行即可完成攻擊。<br> 延伸閱讀：</p> <ul><li><a href="https://cybersecuritynews.com/7-zip-vulnerabilities/">7-Zip Vulnerabilities Let Attackers Execute Arbitrary Code Remotely</a></li></ul> <p>7-Zip 的<a href="https://github.com/ip7z/7zip/releases/tag/25.01">最新版本 25.01</a>已修正這個兩個漏洞，建議大家盡快更新。<br> (題外話：以 7-Zip 的輕巧穩定，執行速度快，功能又完整，Windows 真該把它收為內建工具並自動更新。)</p> <p>為確保修補作業沒有遺漏，我決定寫個 PowerShell 腳本掃瞄資料夾，找出所有 7z.exe/7z.dll 並檢查版本，確保都有更新到最新版。</p> <pre><code>param (
[Parameter(Mandatory = $true)]
[string]$Path,
[string]$CsvPath
)
function CheckVersion($filePath) {
$version = '?'
try {
$version = (Get-Item $filePath).VersionInfo.ProductVersion
$majorVersion = [int]::Parse($version.Split('.')[0])
$passed = $majorVersion -ge 25
$status = if ($passed) { "PASS" } else { "FAIL" }
}
catch {
$status = "ERROR"
}
return [PSCustomObject]@{
Path    = $filePath
Version = $version
Status  = $status
}
}
function ShowResult($result) {
$color = if ($result.Status -eq 'PASS') { 'Green' } elseif ($result.Status -eq 'FAIL') { 'Red' } else { 'Cyan' }
Write-Host "$($result.Status)`t$($result.Version)`t$($result.Path)" -ForegroundColor $color
}
$gciErrors = $null
# -File to ensure we only get files, not directories
# -Force to include hidden/system directories/files
# -ErrorAction SilentlyContinue to suppress errors (e.g., access denied)
# -ErrorVariable gciErrors to capture any errors for later reporting
$results = @()
if ($Path.EndsWith('.csv')) {
$csvPaths = @()
try {
$csvPaths = Import-Csv -Path $Path | ForEach-Object { $_.Path } | Where-Object { Test-Path $_ }
}
catch {
Write-Host "Error reading CSV file: $_" -ForegroundColor Red
exit 1
}
Write-Host "Verifying paths from [$Path]..." -ForegroundColor Yellow
foreach ($csvPath in $csvPaths) {
if (Test-Path $csvPath) {
$result = CheckVersion -filePath $csvPath
ShowResult -result $result
$results += $result
}
else {
$reulst = ([PSCustomObject]@{
Path    = $csvPath
Version = '?'
Status  = '404'
})
ShowResult -result $result
$results += $result
}
}
$CsvPath = $Path
Write-Host "`nUpdating results to [$CsvPath]..." -ForegroundColor Yellow
$results | Export-Csv -Path $CsvPath -NoTypeInformation -Encoding UTF8
}
else {
$sw = [System.Diagnostics.Stopwatch]::StartNew()
Write-Host "Scanning path [$Path] for 7z.exe and 7z.dll files..." -ForegroundColor Yellow
$sw.Start()
Get-ChildItem -Path $Path -Recurse -Filter '7z.*' -File -Force -ErrorAction SilentlyContinue -ErrorVariable gciErrors |
Where-Object { $_.Name -ieq '7z.exe' -or $_.Name -like '7z.dll' } |
ForEach-Object {
$result = CheckVersion -filePath $_.FullName
ShowResult -result $result
$results += $result
}
$sw.Stop()
Write-Host "`nScan completed in $($sw.Elapsed.TotalSeconds.ToString('n0')) seconds." -ForegroundColor Yellow
# Generate default output CSV path
if (-not $CsvPath) {
$CsvPath = Join-Path -Path (Get-Location) -ChildPath "7zip_Scan_$(Get-Date -Format 'yyyyMMdd_HHmmss').csv"
}
Write-Host "`nExporting results to [$CsvPath]..." -ForegroundColor Yellow
$results | Export-Csv -Path $CsvPath -NoTypeInformation -Encoding UTF8
if ($gciErrors) {
$displayErrors = Read-Host "`n$($gciErrors.Count) IO Errors, display? (Y/N)"
if ($displayErrors -ieq 'Y') {
$sb = New-Object -TypeName System.Text.StringBuilder
foreach ($err in $gciErrors) {
$sb.AppendLine($err.Exception.Message) | Out-Null
}
$tempPath = [System.IO.Path]::GetTempFileName() + ".txt"
$sb.ToString() | Out-File -FilePath $tempPath -Encoding UTF8
Start-Process -FilePath $tempPath
}
}
}
</code></pre> <p>使用方法很簡單 <code>Atk-Scan7zipVersion.ps1 D:\</code> 即可找出 D 槽所有的 7z.exe 及 7z.dll 的版本，大於 25.X 的顯示綠色，否則紅色 (無法判斷版號顯示灰色，理論上不會發生)，並將結果存成 CSV。CSV 檔會依日期時間自動命名，或者也可自行指定，例如：<code>Atk-Scan7zipVersion.ps1 D:\ -CsvPath E:\results.csv</code>。</p> <p><img src="https://blog.darkthread.net/Posts/files/2025/Fig1_638961338754718290.png"></p> <p>掃瞄時建議使用管理者權限，但實務上仍可能有些系統目錄會無法存取或找不到路徑，這類存取錯誤訊息會另存暫時目錄，若有需要可以查看。</p> <p>如圖所示，掃瞄一次可能耗時數分鐘，掃瞄結果會存成 CSV 方便後續修補及複核版本是否更新完成。</p> <p><img src="https://blog.darkthread.net/Posts/files/2025/Fig3_638961338756548573.png"></p> <p>如要複核版本狀態，可帶入 CSV 路徑，直接依據清單上的路徑逐一檢查，並將結果更新回 CSV 檔，如此可省下重新掃瞄的時間，在幾秒內完成，。</p> <p><img src="https://blog.darkthread.net/Posts/files/2025/Fig2_638961338758944660.png"></p> <p>至於修補原則，實際掃瞄會發現很多軟體都依賴 7z.exe 解壓縮，例如範例中的 Chocolatey、Visual Studio Xamarin 擴充套件... 等，這類 7z.exe 解壓對象多侷限應用程式自身的套件、更新檔等，不會被用來解壓其他檔案。由於這次的攻擊需使用者互動（如開啟特定惡意 ZIP 檔）才能完成，故風險較高的是使用者日常使用的 7-Zip 程式，至於這類軟體自帶的 7z 程式或程式庫，要被拿來作惡不是那麼容易(BUT，資安有張無敵鬼牌：萬一萬一又萬一)，加上強制置換軟體所屬檔案可能會有副作用，要不要也都更新？就留給大家自行拿捏了。</p> <p data-slug="7z-vulnerabilities-n-scan-tool" data-title-en="7-Zip vulnerabilities warning and version scan tool by PowerShell" data-catg=".NET" data-fbimg="https://cdn.pixabay.com/photo/2023/09/25/20/04/fire-alarm-8275941_1280.jpg#1280#720">Discusses 7-Zip vulnerabilities and shares a PowerShell script to scan, verify, and update 7z.exe/7z.dll versions for enhanced security.</p>]]>
    </description>
    <content:encoded><![CDATA[<p>7-Zip 最近<a href="https://www.facebook.com/will.fans/posts/7-zip-%E5%A3%93%E7%B8%AE%E5%B7%A5%E5%85%B7%E7%99%BC%E7%8F%BE%E5%85%A9%E5%80%8B-cvss-score-%E9%AB%98%E9%81%94-7-%E5%88%86%E7%9A%84-cve-2025-11001-%E8%88%87-cve-2025-11002-%E6%BC%8F%E6%B4%9E-7-zip-%E4%B8%AD%E5%AD%98%E5%9C%A8%E4%B8%80%E5%80%8B/1249133997240687/">被發現兩個安全漏洞：CVE-2025-11001 及 CVE-2025-11002</a>，問題源於 7-Zip 解壓縮時對符號連結（Symbolic Link）與目錄穿越（Directory Traversal）的處理邏輯不夠周全，導致攻擊者可在 ZIP 檔刻意放入特殊的符號連結以「繞出」預期目錄，將惡意檔案覆蓋或寫入到系統敏感位置。一個可行的攻擊途徑是攻擊者設法將惡意 ZIP 檔送到使用者手上並誘騙其進行解壓縮，藉由漏洞將系統服務或使用者常用執行檔換成植入惡意程式的版本，一但加料版被執行即可完成攻擊。<br> 延伸閱讀：</p> <ul><li><a href="https://cybersecuritynews.com/7-zip-vulnerabilities/">7-Zip Vulnerabilities Let Attackers Execute Arbitrary Code Remotely</a></li></ul> <p>7-Zip 的<a href="https://github.com/ip7z/7zip/releases/tag/25.01">最新版本 25.01</a>已修正這個兩個漏洞，建議大家盡快更新。<br> (題外話：以 7-Zip 的輕巧穩定，執行速度快，功能又完整，Windows 真該把它收為內建工具並自動更新。)</p> <p>為確保修補作業沒有遺漏，我決定寫個 PowerShell 腳本掃瞄資料夾，找出所有 7z.exe/7z.dll 並檢查版本，確保都有更新到最新版。</p> <pre><code>param (
[Parameter(Mandatory = $true)]
[string]$Path,
[string]$CsvPath
)
function CheckVersion($filePath) {
$version = '?'
try {
$version = (Get-Item $filePath).VersionInfo.ProductVersion
$majorVersion = [int]::Parse($version.Split('.')[0])
$passed = $majorVersion -ge 25
$status = if ($passed) { "PASS" } else { "FAIL" }
}
catch {
$status = "ERROR"
}
return [PSCustomObject]@{
Path    = $filePath
Version = $version
Status  = $status
}
}
function ShowResult($result) {
$color = if ($result.Status -eq 'PASS') { 'Green' } elseif ($result.Status -eq 'FAIL') { 'Red' } else { 'Cyan' }
Write-Host "$($result.Status)`t$($result.Version)`t$($result.Path)" -ForegroundColor $color
}
$gciErrors = $null
# -File to ensure we only get files, not directories
# -Force to include hidden/system directories/files
# -ErrorAction SilentlyContinue to suppress errors (e.g., access denied)
# -ErrorVariable gciErrors to capture any errors for later reporting
$results = @()
if ($Path.EndsWith('.csv')) {
$csvPaths = @()
try {
$csvPaths = Import-Csv -Path $Path | ForEach-Object { $_.Path } | Where-Object { Test-Path $_ }
}
catch {
Write-Host "Error reading CSV file: $_" -ForegroundColor Red
exit 1
}
Write-Host "Verifying paths from [$Path]..." -ForegroundColor Yellow
foreach ($csvPath in $csvPaths) {
if (Test-Path $csvPath) {
$result = CheckVersion -filePath $csvPath
ShowResult -result $result
$results += $result
}
else {
$reulst = ([PSCustomObject]@{
Path    = $csvPath
Version = '?'
Status  = '404'
})
ShowResult -result $result
$results += $result
}
}
$CsvPath = $Path
Write-Host "`nUpdating results to [$CsvPath]..." -ForegroundColor Yellow
$results | Export-Csv -Path $CsvPath -NoTypeInformation -Encoding UTF8
}
else {
$sw = [System.Diagnostics.Stopwatch]::StartNew()
Write-Host "Scanning path [$Path] for 7z.exe and 7z.dll files..." -ForegroundColor Yellow
$sw.Start()
Get-ChildItem -Path $Path -Recurse -Filter '7z.*' -File -Force -ErrorAction SilentlyContinue -ErrorVariable gciErrors |
Where-Object { $_.Name -ieq '7z.exe' -or $_.Name -like '7z.dll' } |
ForEach-Object {
$result = CheckVersion -filePath $_.FullName
ShowResult -result $result
$results += $result
}
$sw.Stop()
Write-Host "`nScan completed in $($sw.Elapsed.TotalSeconds.ToString('n0')) seconds." -ForegroundColor Yellow
# Generate default output CSV path
if (-not $CsvPath) {
$CsvPath = Join-Path -Path (Get-Location) -ChildPath "7zip_Scan_$(Get-Date -Format 'yyyyMMdd_HHmmss').csv"
}
Write-Host "`nExporting results to [$CsvPath]..." -ForegroundColor Yellow
$results | Export-Csv -Path $CsvPath -NoTypeInformation -Encoding UTF8
if ($gciErrors) {
$displayErrors = Read-Host "`n$($gciErrors.Count) IO Errors, display? (Y/N)"
if ($displayErrors -ieq 'Y') {
$sb = New-Object -TypeName System.Text.StringBuilder
foreach ($err in $gciErrors) {
$sb.AppendLine($err.Exception.Message) | Out-Null
}
$tempPath = [System.IO.Path]::GetTempFileName() + ".txt"
$sb.ToString() | Out-File -FilePath $tempPath -Encoding UTF8
Start-Process -FilePath $tempPath
}
}
}
</code></pre> <p>使用方法很簡單 <code>Atk-Scan7zipVersion.ps1 D:\</code> 即可找出 D 槽所有的 7z.exe 及 7z.dll 的版本，大於 25.X 的顯示綠色，否則紅色 (無法判斷版號顯示灰色，理論上不會發生)，並將結果存成 CSV。CSV 檔會依日期時間自動命名，或者也可自行指定，例如：<code>Atk-Scan7zipVersion.ps1 D:\ -CsvPath E:\results.csv</code>。</p> <p><img src="https://blog.darkthread.net/Posts/files/2025/Fig1_638961338754718290.png"></p> <p>掃瞄時建議使用管理者權限，但實務上仍可能有些系統目錄會無法存取或找不到路徑，這類存取錯誤訊息會另存暫時目錄，若有需要可以查看。</p> <p>如圖所示，掃瞄一次可能耗時數分鐘，掃瞄結果會存成 CSV 方便後續修補及複核版本是否更新完成。</p> <p><img src="https://blog.darkthread.net/Posts/files/2025/Fig3_638961338756548573.png"></p> <p>如要複核版本狀態，可帶入 CSV 路徑，直接依據清單上的路徑逐一檢查，並將結果更新回 CSV 檔，如此可省下重新掃瞄的時間，在幾秒內完成，。</p> <p><img src="https://blog.darkthread.net/Posts/files/2025/Fig2_638961338758944660.png"></p> <p>至於修補原則，實際掃瞄會發現很多軟體都依賴 7z.exe 解壓縮，例如範例中的 Chocolatey、Visual Studio Xamarin 擴充套件... 等，這類 7z.exe 解壓對象多侷限應用程式自身的套件、更新檔等，不會被用來解壓其他檔案。由於這次的攻擊需使用者互動（如開啟特定惡意 ZIP 檔）才能完成，故風險較高的是使用者日常使用的 7-Zip 程式，至於這類軟體自帶的 7z 程式或程式庫，要被拿來作惡不是那麼容易(BUT，資安有張無敵鬼牌：萬一萬一又萬一)，加上強制置換軟體所屬檔案可能會有副作用，要不要也都更新？就留給大家自行拿捏了。</p> <p data-slug="7z-vulnerabilities-n-scan-tool" data-title-en="7-Zip vulnerabilities warning and version scan tool by PowerShell" data-catg=".NET" data-fbimg="https://cdn.pixabay.com/photo/2023/09/25/20/04/fire-alarm-8275941_1280.jpg#1280#720">Discusses 7-Zip vulnerabilities and shares a PowerShell script to scan, verify, and update 7z.exe/7z.dll versions for enhanced security.</p>]]></content:encoded>
    <itunes:image href="https://blog.darkthread.net/Posts/files/2025/Fig1_638961338754718290.png"/>
          <media:content url="https://blog.darkthread.net/Posts/files/2025/Fig1_638961338754718290.png" medium="image"/>
    <pubDate>Wed, 15 Oct 2025 14:01:37 GMT</pubDate>
  </item><item>
    <title><![CDATA[再談單一網域名稱 (FQDN) 對映多 IP]]></title>
    <link>https://blog.darkthread.net/blog/multi-ip-for-fqdn/</link>
    <itunes:title><![CDATA[再談單一網域名稱 (FQDN) 對映多 IP]]></itunes:title>
    <itunes:author><![CDATA[service@darkthread.net (Jeffrey Lee)]]></itunes:author>
    <itunes:summary>
      <![CDATA[<p>因為久久才會處理到一次，對 DNS 網域名稱對映多 IP 的概念有點模糊，導致最近查問題時一度誤入歧途... 再寫篇筆記強化記憶好惹。</p> <p>要讓同一個 FQDN (完整網域名稱，例如：blog.darkthread.net) 對映多個 IP，常見有以下做法：</p> <h3>RR-DNS (Round-Robin DNS)</h3> <p>在同一名稱下放多筆 A 或 AAAA 記錄，權威 DNS 回覆查詢時輪換 IP 記錄的順序，客戶端一般會優先連到清單第一筆，藉此可平均分散流量到多台伺服器上，並勉強具有備援效果(連到故障 IP，重試幾次有機會換到正常主機)。<br> 這種古老做法簡單粗暴，不需要額外設備，不限 DNS 伺服器版本，還能透過隨機性分攤流量，但缺點是無法依實際負載與健康狀況動態調度，另外 DNS 快取可能干擾效果。<br> 最簡單辨別 RR-DBS 方法是用 nslookup 查詢網域名稱，若結果包含多個 IP，每次查詢順序不同就是了。(下圖是用 technitium/dns-server Docker 隨手架的 DNS 伺服器，模擬 RR-DNS 的效果)<br> <img src="https://blog.darkthread.net/Posts/files/2025/Fig3_638960497343783839.png"><br> 實務上候選 IP 數量與每次返回 IP 數量可自行安排，每次看到 IP 不一定包含所有可能 IP。(如下圖)<br> <img src="https://blog.darkthread.net/Posts/files/2025/Fig2_638960497346949102.png"><br> (延伸閱讀：<a href="/blog/round-robin-dns-test/">RR-DNS 隨機配發 IP 實驗</a>)</p> <h3>加權與政策型 DNS</h3> <p>在 Round‑Robin DNS 上加入權重、來源地理/子網政策、時間或端點健康度，透過回覆集的動態組合調整流量比例與落點。<a href="https://learn.microsoft.com/zh-tw/windows-server/networking/dns/deploy/app-lb?WT.mc_id=DOP-MVP-37580#how-application-load-balancing-works">微軟 Windows DNS 有提供類似功能</a></p> <h3>雲端流量路由管理</h3> <p>Azure 等雲端服務也有提供所謂的<a href="https://learn.microsoft.com/zh-tw/azure/traffic-manager/traffic-manager-how-it-works?WT.mc_id=DOP-MVP-37580">流量管理員</a>，如 login.microsoft.com 會先用 CNAME 指向 <code>a.privatelink.msidentity.com</code>、再指向 <code>prda.aadg.msidentity.com</code>、再指向 <code>www.tm.a.prd.aadg.trafficmanager.net</code> ，最後回傳 8 筆隨機挑選及排序的 IP：<br> <img src="https://blog.darkthread.net/Posts/files/2025/Fig4_638960497348720368.png"><br> 流量路由方法可依據權重、效能、地理位置、來源網段決定服務端點，概念類似前面提過的加權與政策型 DNS。</p> <h3>導向 CDN</h3> <p>改用 CNAME 導向 CDN 供應商的網域，而 CDN 再依地理/延遲/健康/容量等信號決定實際邊緣(如下圖中的 <em>.akamaiedge.net)或來源節點，動態回覆 IP，此一做法亦常與 Anycast、邊緣代理、動態路由等技術結合。<br> <img src="https://blog.darkthread.net/Posts/files/2025/Fig5_638960497350421608.png"><br> CDN 廠商通常在全球部署節點，依據地理位置與當下狀況動態決定最適合 IP (或是使用相同 IP 再靠 Anycast 技術找出最近節點，例如下圖的 104.16.</em> IP 屬於 Cloudflare <a href="https://ipinfo.io/AS13335">自治系統 AS13335</a>，是其全球 Anycast 網路的一部分)，一般能提供較佳體驗。<br> <img src="https://blog.darkthread.net/Posts/files/2025/Fig6_638960497352016123.png"><br> 延伸閱讀：Anycast - <a href="/blog/bgp-anycast/">Internet 跟你想的不一樣：IP 地址不是唯一，有許多相同 IP 的主機散落各地</a></p> <h3>GeoDNS</h3> <p>GeoDNS 可依地理位置傳回不同的 IP，但需要支援 Geolocation 的 DNS 伺服器，依據來源端 IP 查 GeoIP 資料庫回傳距離較近的 IP。優點是容易架設、成本較低，如果要以國別區分管理時特別好用(例如：Netflix 的美國觀眾連美國主機)。缺點則是以國家或地區為單位較不精準、GeoIP 資料可能失真、增加新區域主機時 DNS 修改作業很麻煩。</p> <h3>小結</h3> <p>回到實務面，若我們要想出某個 FQDN 對映哪些 IP 好開放防火牆，除了 RR-DNS 可以一次由 nslookup 結果取得多個 IP (若每次顯示筆數只佔侯選清單的一部分，仍需多次查詢) 或啟用 Anycast 會返回固定 IP，其餘狀況都需要反覆嘗試，蒐集每次傳回的結果才能知道。若多 IP 筆數不多，回應屬隨機性與地理因素無關，則之前介紹過的 <a href="/blog/whatsmydns-net/">whatsmydns.net</a> 可以一次看到從全世界不同地區查詢到的結果，快速肉眼求解。</p> <p>其實，拿到 FQDN 對映 IP 清單更好的做法是向服務擁有者索取，中大型服務也多半會主動提供清單(例如 <a href="https://learn.microsoft.com/zh-tw/azure/devops/organizations/security/allow-list-ip-url?view=azure-devops&amp;tabs=IP-V4&amp;WT.mc_id=DOP-MVP-37580">Azure DevOps 允許的 IP 位址和網域 URL</a>、<a href="https://support.google.com/a/answer/10026322?hl=en">Obtain Google IP address ranges</a>)，會比自己整理快速可靠。</p> <p data-slug="multi-ip-for-fqdn" data-fbimg="https://cdn.pixabay.com/photo/2017/07/01/17/30/mailbox-2462122_960_720.jpg#960#720"> </p>]]>
    </itunes:summary>
    <description>
      <![CDATA[<p>因為久久才會處理到一次，對 DNS 網域名稱對映多 IP 的概念有點模糊，導致最近查問題時一度誤入歧途... 再寫篇筆記強化記憶好惹。</p> <p>要讓同一個 FQDN (完整網域名稱，例如：blog.darkthread.net) 對映多個 IP，常見有以下做法：</p> <h3>RR-DNS (Round-Robin DNS)</h3> <p>在同一名稱下放多筆 A 或 AAAA 記錄，權威 DNS 回覆查詢時輪換 IP 記錄的順序，客戶端一般會優先連到清單第一筆，藉此可平均分散流量到多台伺服器上，並勉強具有備援效果(連到故障 IP，重試幾次有機會換到正常主機)。<br> 這種古老做法簡單粗暴，不需要額外設備，不限 DNS 伺服器版本，還能透過隨機性分攤流量，但缺點是無法依實際負載與健康狀況動態調度，另外 DNS 快取可能干擾效果。<br> 最簡單辨別 RR-DBS 方法是用 nslookup 查詢網域名稱，若結果包含多個 IP，每次查詢順序不同就是了。(下圖是用 technitium/dns-server Docker 隨手架的 DNS 伺服器，模擬 RR-DNS 的效果)<br> <img src="https://blog.darkthread.net/Posts/files/2025/Fig3_638960497343783839.png"><br> 實務上候選 IP 數量與每次返回 IP 數量可自行安排，每次看到 IP 不一定包含所有可能 IP。(如下圖)<br> <img src="https://blog.darkthread.net/Posts/files/2025/Fig2_638960497346949102.png"><br> (延伸閱讀：<a href="/blog/round-robin-dns-test/">RR-DNS 隨機配發 IP 實驗</a>)</p> <h3>加權與政策型 DNS</h3> <p>在 Round‑Robin DNS 上加入權重、來源地理/子網政策、時間或端點健康度，透過回覆集的動態組合調整流量比例與落點。<a href="https://learn.microsoft.com/zh-tw/windows-server/networking/dns/deploy/app-lb?WT.mc_id=DOP-MVP-37580#how-application-load-balancing-works">微軟 Windows DNS 有提供類似功能</a></p> <h3>雲端流量路由管理</h3> <p>Azure 等雲端服務也有提供所謂的<a href="https://learn.microsoft.com/zh-tw/azure/traffic-manager/traffic-manager-how-it-works?WT.mc_id=DOP-MVP-37580">流量管理員</a>，如 login.microsoft.com 會先用 CNAME 指向 <code>a.privatelink.msidentity.com</code>、再指向 <code>prda.aadg.msidentity.com</code>、再指向 <code>www.tm.a.prd.aadg.trafficmanager.net</code> ，最後回傳 8 筆隨機挑選及排序的 IP：<br> <img src="https://blog.darkthread.net/Posts/files/2025/Fig4_638960497348720368.png"><br> 流量路由方法可依據權重、效能、地理位置、來源網段決定服務端點，概念類似前面提過的加權與政策型 DNS。</p> <h3>導向 CDN</h3> <p>改用 CNAME 導向 CDN 供應商的網域，而 CDN 再依地理/延遲/健康/容量等信號決定實際邊緣(如下圖中的 <em>.akamaiedge.net)或來源節點，動態回覆 IP，此一做法亦常與 Anycast、邊緣代理、動態路由等技術結合。<br> <img src="https://blog.darkthread.net/Posts/files/2025/Fig5_638960497350421608.png"><br> CDN 廠商通常在全球部署節點，依據地理位置與當下狀況動態決定最適合 IP (或是使用相同 IP 再靠 Anycast 技術找出最近節點，例如下圖的 104.16.</em> IP 屬於 Cloudflare <a href="https://ipinfo.io/AS13335">自治系統 AS13335</a>，是其全球 Anycast 網路的一部分)，一般能提供較佳體驗。<br> <img src="https://blog.darkthread.net/Posts/files/2025/Fig6_638960497352016123.png"><br> 延伸閱讀：Anycast - <a href="/blog/bgp-anycast/">Internet 跟你想的不一樣：IP 地址不是唯一，有許多相同 IP 的主機散落各地</a></p> <h3>GeoDNS</h3> <p>GeoDNS 可依地理位置傳回不同的 IP，但需要支援 Geolocation 的 DNS 伺服器，依據來源端 IP 查 GeoIP 資料庫回傳距離較近的 IP。優點是容易架設、成本較低，如果要以國別區分管理時特別好用(例如：Netflix 的美國觀眾連美國主機)。缺點則是以國家或地區為單位較不精準、GeoIP 資料可能失真、增加新區域主機時 DNS 修改作業很麻煩。</p> <h3>小結</h3> <p>回到實務面，若我們要想出某個 FQDN 對映哪些 IP 好開放防火牆，除了 RR-DNS 可以一次由 nslookup 結果取得多個 IP (若每次顯示筆數只佔侯選清單的一部分，仍需多次查詢) 或啟用 Anycast 會返回固定 IP，其餘狀況都需要反覆嘗試，蒐集每次傳回的結果才能知道。若多 IP 筆數不多，回應屬隨機性與地理因素無關，則之前介紹過的 <a href="/blog/whatsmydns-net/">whatsmydns.net</a> 可以一次看到從全世界不同地區查詢到的結果，快速肉眼求解。</p> <p>其實，拿到 FQDN 對映 IP 清單更好的做法是向服務擁有者索取，中大型服務也多半會主動提供清單(例如 <a href="https://learn.microsoft.com/zh-tw/azure/devops/organizations/security/allow-list-ip-url?view=azure-devops&amp;tabs=IP-V4&amp;WT.mc_id=DOP-MVP-37580">Azure DevOps 允許的 IP 位址和網域 URL</a>、<a href="https://support.google.com/a/answer/10026322?hl=en">Obtain Google IP address ranges</a>)，會比自己整理快速可靠。</p> <p data-slug="multi-ip-for-fqdn" data-fbimg="https://cdn.pixabay.com/photo/2017/07/01/17/30/mailbox-2462122_960_720.jpg#960#720"> </p>]]>
    </description>
    <content:encoded><![CDATA[<p>因為久久才會處理到一次，對 DNS 網域名稱對映多 IP 的概念有點模糊，導致最近查問題時一度誤入歧途... 再寫篇筆記強化記憶好惹。</p> <p>要讓同一個 FQDN (完整網域名稱，例如：blog.darkthread.net) 對映多個 IP，常見有以下做法：</p> <h3>RR-DNS (Round-Robin DNS)</h3> <p>在同一名稱下放多筆 A 或 AAAA 記錄，權威 DNS 回覆查詢時輪換 IP 記錄的順序，客戶端一般會優先連到清單第一筆，藉此可平均分散流量到多台伺服器上，並勉強具有備援效果(連到故障 IP，重試幾次有機會換到正常主機)。<br> 這種古老做法簡單粗暴，不需要額外設備，不限 DNS 伺服器版本，還能透過隨機性分攤流量，但缺點是無法依實際負載與健康狀況動態調度，另外 DNS 快取可能干擾效果。<br> 最簡單辨別 RR-DBS 方法是用 nslookup 查詢網域名稱，若結果包含多個 IP，每次查詢順序不同就是了。(下圖是用 technitium/dns-server Docker 隨手架的 DNS 伺服器，模擬 RR-DNS 的效果)<br> <img src="https://blog.darkthread.net/Posts/files/2025/Fig3_638960497343783839.png"><br> 實務上候選 IP 數量與每次返回 IP 數量可自行安排，每次看到 IP 不一定包含所有可能 IP。(如下圖)<br> <img src="https://blog.darkthread.net/Posts/files/2025/Fig2_638960497346949102.png"><br> (延伸閱讀：<a href="/blog/round-robin-dns-test/">RR-DNS 隨機配發 IP 實驗</a>)</p> <h3>加權與政策型 DNS</h3> <p>在 Round‑Robin DNS 上加入權重、來源地理/子網政策、時間或端點健康度，透過回覆集的動態組合調整流量比例與落點。<a href="https://learn.microsoft.com/zh-tw/windows-server/networking/dns/deploy/app-lb?WT.mc_id=DOP-MVP-37580#how-application-load-balancing-works">微軟 Windows DNS 有提供類似功能</a></p> <h3>雲端流量路由管理</h3> <p>Azure 等雲端服務也有提供所謂的<a href="https://learn.microsoft.com/zh-tw/azure/traffic-manager/traffic-manager-how-it-works?WT.mc_id=DOP-MVP-37580">流量管理員</a>，如 login.microsoft.com 會先用 CNAME 指向 <code>a.privatelink.msidentity.com</code>、再指向 <code>prda.aadg.msidentity.com</code>、再指向 <code>www.tm.a.prd.aadg.trafficmanager.net</code> ，最後回傳 8 筆隨機挑選及排序的 IP：<br> <img src="https://blog.darkthread.net/Posts/files/2025/Fig4_638960497348720368.png"><br> 流量路由方法可依據權重、效能、地理位置、來源網段決定服務端點，概念類似前面提過的加權與政策型 DNS。</p> <h3>導向 CDN</h3> <p>改用 CNAME 導向 CDN 供應商的網域，而 CDN 再依地理/延遲/健康/容量等信號決定實際邊緣(如下圖中的 <em>.akamaiedge.net)或來源節點，動態回覆 IP，此一做法亦常與 Anycast、邊緣代理、動態路由等技術結合。<br> <img src="https://blog.darkthread.net/Posts/files/2025/Fig5_638960497350421608.png"><br> CDN 廠商通常在全球部署節點，依據地理位置與當下狀況動態決定最適合 IP (或是使用相同 IP 再靠 Anycast 技術找出最近節點，例如下圖的 104.16.</em> IP 屬於 Cloudflare <a href="https://ipinfo.io/AS13335">自治系統 AS13335</a>，是其全球 Anycast 網路的一部分)，一般能提供較佳體驗。<br> <img src="https://blog.darkthread.net/Posts/files/2025/Fig6_638960497352016123.png"><br> 延伸閱讀：Anycast - <a href="/blog/bgp-anycast/">Internet 跟你想的不一樣：IP 地址不是唯一，有許多相同 IP 的主機散落各地</a></p> <h3>GeoDNS</h3> <p>GeoDNS 可依地理位置傳回不同的 IP，但需要支援 Geolocation 的 DNS 伺服器，依據來源端 IP 查 GeoIP 資料庫回傳距離較近的 IP。優點是容易架設、成本較低，如果要以國別區分管理時特別好用(例如：Netflix 的美國觀眾連美國主機)。缺點則是以國家或地區為單位較不精準、GeoIP 資料可能失真、增加新區域主機時 DNS 修改作業很麻煩。</p> <h3>小結</h3> <p>回到實務面，若我們要想出某個 FQDN 對映哪些 IP 好開放防火牆，除了 RR-DNS 可以一次由 nslookup 結果取得多個 IP (若每次顯示筆數只佔侯選清單的一部分，仍需多次查詢) 或啟用 Anycast 會返回固定 IP，其餘狀況都需要反覆嘗試，蒐集每次傳回的結果才能知道。若多 IP 筆數不多，回應屬隨機性與地理因素無關，則之前介紹過的 <a href="/blog/whatsmydns-net/">whatsmydns.net</a> 可以一次看到從全世界不同地區查詢到的結果，快速肉眼求解。</p> <p>其實，拿到 FQDN 對映 IP 清單更好的做法是向服務擁有者索取，中大型服務也多半會主動提供清單(例如 <a href="https://learn.microsoft.com/zh-tw/azure/devops/organizations/security/allow-list-ip-url?view=azure-devops&amp;tabs=IP-V4&amp;WT.mc_id=DOP-MVP-37580">Azure DevOps 允許的 IP 位址和網域 URL</a>、<a href="https://support.google.com/a/answer/10026322?hl=en">Obtain Google IP address ranges</a>)，會比自己整理快速可靠。</p> <p data-slug="multi-ip-for-fqdn" data-fbimg="https://cdn.pixabay.com/photo/2017/07/01/17/30/mailbox-2462122_960_720.jpg#960#720"> </p>]]></content:encoded>
    <itunes:image href="https://blog.darkthread.net/Posts/files/2025/Fig3_638960497343783839.png"/>
          <media:content url="https://blog.darkthread.net/Posts/files/2025/Fig3_638960497343783839.png" medium="image"/>
    <pubDate>Tue, 14 Oct 2025 14:41:44 GMT</pubDate>
  </item><item>
    <title><![CDATA[當超寬表格遇上手機直式螢幕]]></title>
    <link>https://blog.darkthread.net/blog/wide-table-rwd/</link>
    <itunes:title><![CDATA[當超寬表格遇上手機直式螢幕]]></itunes:title>
    <itunes:author><![CDATA[service@darkthread.net (Jeffrey Lee)]]></itunes:author>
    <itunes:summary>
      <![CDATA[<p>前天跟大家分享了<a href="/blog/chinese-it-term-translation-instant-lookup/">我養的牛牛</a>，很快就接到網友 ycs77 回饋，提到現有介面用手機直式顯示時排版會亂掉且不易閱讀，還幫忙微調樣式發了 PR，好一位充滿行動力的熱血同學，RESPECT!</p> <p>這些年來，行動裝置客戶端的比例逐年上升，連我部落格這種以工作參考為主的網站，理論上最大客源來自上班遇到茶包爬文(話說，自後 LLM 興起部落格流量也跟著一路下滑 Orz 問 AI 直接有答案，誰還開網站？)，但近年來桌機仍是最大宗，但行動裝置的比例也常維持在 30% ~ 40% 之間，成為不可忽視的一群。</p> <p><img src="https://blog.darkthread.net/Posts/files/2025/Fig2_638959640315157964.png"></p> <p>實際用手機測了一下，目前的介面完全沒考量到行動裝置直式螢幕，標題與關鍵字欄位跑版不說，結果表格寬度超出螢幕，需要上下左右滑，一整個不專業。</p> <p><img src="https://blog.darkthread.net/Posts/files/2025/Fig1_638959640318920496.jpg" alt="thumbnail"></p> <p>我不想為手機版另外設計一套排版，希望依據寬度切換樣式就能輕鬆搞定，但我的前端技能只有半調子，對 RWD 也沒啥研究... 以前走到這步通常要卡關卡很久，但現在有 Github Copilot 在手，相當於有精通前端設計的神隊友，這樣還搞砸神仙難救!</p> <p>Copilot 給了三種建議：改為卡片式佈局(Card Layout)、加上水平捲軸、隱藏次要欄位縮短寬度，在我的經驗裡卡片式佈局應是最專業最常見的設計方式，也是 Copilot 最推薦的做法。</p> <p>然後，用點小技巧，TABLD/TR/TD 結構可以完全不用動。主要原理是使用 <code>@media (max-width: 768px)</code> 針對寬度 768px 以下改用另一組樣式，有幾個重點：</p> <ul><li>上方標題及文字欄位改用 flex 直式排列</li> <li>將 table, tr, td 都改成 display: block</li> <li>tbody 設定 <code>display: grid</code>，讓 tr 以網格排列，配合 <code>grid-template-columns: repeat(2, 1fr);</code> (重複兩次，每次 1 fraction unit) 設定兩欄</li> <li>英文改藍字、字型加大、粗體</li> <li>英文以外的中文 td，設定 <code>td::before</code> 在前方用 <code>content: attr(data-label)</code> 顯示 data-label Attribute 值 (zh-tw|zh-cn|zh-hk|zh-sg|zh-mo|zh-my)</li> <li>zh-tw/zh-cn 以外的中文 td 用 Vue <code>:class="{'empty': !term.hk}"</code> 設定沒有內容時加上 empty 樣式，再將 .empty 設成 display: none 隱藏</li></ul> <pre><code>/* 寬度小於 768px 時啟用卡片式佈局 */
@media (max-width: 768px) {
header {
/* 改為直向排列 */
flex-direction: column;
align-items: flex-start;
gap: 10px;
h1 {
font-size: 1.3em;
margin: 0;
}
/* 說明連結改為右上角 */
.doc {
position: absolute;
top: 6px;
right: 12px;
z-index: 100;
}
}
/* 參照來源位置微調 */
.content .ref {
margin-top: 12px;
text-align: left;
font-size: 80%;
}
/* 隱藏表格標題列 */
table thead {
display: none;
}
/* 將表格、列與欄都轉換為 Block 排版 */
table {
display: block;
tbody, tr, td {
display: block;
}
}
/* tr 使用 Grid 佈局，並設定成兩欄顯示 */
table tbody {
display: grid;
grid-template-columns: repeat(2, 1fr);
gap: 12px;
}
/* tr 樣式設計成一張卡片 */
table tr {
margin-bottom: 0;
border: 2px solid #ddd;
border-radius: 8px;
padding: 12px;
background: white;
box-shadow: 0 1px 1px rgba(0, 0, 0, 0.5);
}
table td {
border: none;
padding: 2px 0;
text-align: left;
position: relative;
padding-left: 64px;
min-height: 1.2em;
}
/* 在每個儲存格前顯示欄位標籤 */
table td::before {
content: attr(data-label);
position: absolute;
left: 0;
width: 64px;
font-weight: bold;
color: #666;
font-size: 0.9em;
}
/* 英文欄位：藍色、字體放大、粗體 */
table td.en {
font-size: 1.1em;
font-weight: bold;
padding-left: 0;
padding-bottom: 8px;
margin-bottom: 8px;
border-bottom: 1px solid #eee;
/* 前方不需標籤 */
&amp;::before {
display: none;
}
}
/* 針對相同值樣式調整 */
table tr.same td.tw,
table tr.same td.cn {
opacity: 0.5;
font-style: italic;
}
/* 隱藏空白欄位(zh-hk...) */
table td.empty {
display: none;
}
}
</code></pre> <p>嗯，不能跟專業設計比，但比表格好看好用多了。 <a href="https://darkthread.github.io/comp-terms/">中文計算機術語速查工具</a></p> <p><img src="https://blog.darkthread.net/Posts/files/2025/Fig3_638959640322515830.jpg"></p> <p data-slug="wide-table-rwd" data-title-en="Showing wide table on mobile screen" data-catg="Web Development" data-fbimg="https://cdn.pixabay.com/photo/2016/11/22/23/40/hands-1851218_1280.jpg#1280#720">Improved the Chinese IT term lookup tool’s mobile layout with responsive card-style design using CSS media queries, enhancing readability and usability on smartphones.</p>]]>
    </itunes:summary>
    <description>
      <![CDATA[<p>前天跟大家分享了<a href="/blog/chinese-it-term-translation-instant-lookup/">我養的牛牛</a>，很快就接到網友 ycs77 回饋，提到現有介面用手機直式顯示時排版會亂掉且不易閱讀，還幫忙微調樣式發了 PR，好一位充滿行動力的熱血同學，RESPECT!</p> <p>這些年來，行動裝置客戶端的比例逐年上升，連我部落格這種以工作參考為主的網站，理論上最大客源來自上班遇到茶包爬文(話說，自後 LLM 興起部落格流量也跟著一路下滑 Orz 問 AI 直接有答案，誰還開網站？)，但近年來桌機仍是最大宗，但行動裝置的比例也常維持在 30% ~ 40% 之間，成為不可忽視的一群。</p> <p><img src="https://blog.darkthread.net/Posts/files/2025/Fig2_638959640315157964.png"></p> <p>實際用手機測了一下，目前的介面完全沒考量到行動裝置直式螢幕，標題與關鍵字欄位跑版不說，結果表格寬度超出螢幕，需要上下左右滑，一整個不專業。</p> <p><img src="https://blog.darkthread.net/Posts/files/2025/Fig1_638959640318920496.jpg" alt="thumbnail"></p> <p>我不想為手機版另外設計一套排版，希望依據寬度切換樣式就能輕鬆搞定，但我的前端技能只有半調子，對 RWD 也沒啥研究... 以前走到這步通常要卡關卡很久，但現在有 Github Copilot 在手，相當於有精通前端設計的神隊友，這樣還搞砸神仙難救!</p> <p>Copilot 給了三種建議：改為卡片式佈局(Card Layout)、加上水平捲軸、隱藏次要欄位縮短寬度，在我的經驗裡卡片式佈局應是最專業最常見的設計方式，也是 Copilot 最推薦的做法。</p> <p>然後，用點小技巧，TABLD/TR/TD 結構可以完全不用動。主要原理是使用 <code>@media (max-width: 768px)</code> 針對寬度 768px 以下改用另一組樣式，有幾個重點：</p> <ul><li>上方標題及文字欄位改用 flex 直式排列</li> <li>將 table, tr, td 都改成 display: block</li> <li>tbody 設定 <code>display: grid</code>，讓 tr 以網格排列，配合 <code>grid-template-columns: repeat(2, 1fr);</code> (重複兩次，每次 1 fraction unit) 設定兩欄</li> <li>英文改藍字、字型加大、粗體</li> <li>英文以外的中文 td，設定 <code>td::before</code> 在前方用 <code>content: attr(data-label)</code> 顯示 data-label Attribute 值 (zh-tw|zh-cn|zh-hk|zh-sg|zh-mo|zh-my)</li> <li>zh-tw/zh-cn 以外的中文 td 用 Vue <code>:class="{'empty': !term.hk}"</code> 設定沒有內容時加上 empty 樣式，再將 .empty 設成 display: none 隱藏</li></ul> <pre><code>/* 寬度小於 768px 時啟用卡片式佈局 */
@media (max-width: 768px) {
header {
/* 改為直向排列 */
flex-direction: column;
align-items: flex-start;
gap: 10px;
h1 {
font-size: 1.3em;
margin: 0;
}
/* 說明連結改為右上角 */
.doc {
position: absolute;
top: 6px;
right: 12px;
z-index: 100;
}
}
/* 參照來源位置微調 */
.content .ref {
margin-top: 12px;
text-align: left;
font-size: 80%;
}
/* 隱藏表格標題列 */
table thead {
display: none;
}
/* 將表格、列與欄都轉換為 Block 排版 */
table {
display: block;
tbody, tr, td {
display: block;
}
}
/* tr 使用 Grid 佈局，並設定成兩欄顯示 */
table tbody {
display: grid;
grid-template-columns: repeat(2, 1fr);
gap: 12px;
}
/* tr 樣式設計成一張卡片 */
table tr {
margin-bottom: 0;
border: 2px solid #ddd;
border-radius: 8px;
padding: 12px;
background: white;
box-shadow: 0 1px 1px rgba(0, 0, 0, 0.5);
}
table td {
border: none;
padding: 2px 0;
text-align: left;
position: relative;
padding-left: 64px;
min-height: 1.2em;
}
/* 在每個儲存格前顯示欄位標籤 */
table td::before {
content: attr(data-label);
position: absolute;
left: 0;
width: 64px;
font-weight: bold;
color: #666;
font-size: 0.9em;
}
/* 英文欄位：藍色、字體放大、粗體 */
table td.en {
font-size: 1.1em;
font-weight: bold;
padding-left: 0;
padding-bottom: 8px;
margin-bottom: 8px;
border-bottom: 1px solid #eee;
/* 前方不需標籤 */
&amp;::before {
display: none;
}
}
/* 針對相同值樣式調整 */
table tr.same td.tw,
table tr.same td.cn {
opacity: 0.5;
font-style: italic;
}
/* 隱藏空白欄位(zh-hk...) */
table td.empty {
display: none;
}
}
</code></pre> <p>嗯，不能跟專業設計比，但比表格好看好用多了。 <a href="https://darkthread.github.io/comp-terms/">中文計算機術語速查工具</a></p> <p><img src="https://blog.darkthread.net/Posts/files/2025/Fig3_638959640322515830.jpg"></p> <p data-slug="wide-table-rwd" data-title-en="Showing wide table on mobile screen" data-catg="Web Development" data-fbimg="https://cdn.pixabay.com/photo/2016/11/22/23/40/hands-1851218_1280.jpg#1280#720">Improved the Chinese IT term lookup tool’s mobile layout with responsive card-style design using CSS media queries, enhancing readability and usability on smartphones.</p>]]>
    </description>
    <content:encoded><![CDATA[<p>前天跟大家分享了<a href="/blog/chinese-it-term-translation-instant-lookup/">我養的牛牛</a>，很快就接到網友 ycs77 回饋，提到現有介面用手機直式顯示時排版會亂掉且不易閱讀，還幫忙微調樣式發了 PR，好一位充滿行動力的熱血同學，RESPECT!</p> <p>這些年來，行動裝置客戶端的比例逐年上升，連我部落格這種以工作參考為主的網站，理論上最大客源來自上班遇到茶包爬文(話說，自後 LLM 興起部落格流量也跟著一路下滑 Orz 問 AI 直接有答案，誰還開網站？)，但近年來桌機仍是最大宗，但行動裝置的比例也常維持在 30% ~ 40% 之間，成為不可忽視的一群。</p> <p><img src="https://blog.darkthread.net/Posts/files/2025/Fig2_638959640315157964.png"></p> <p>實際用手機測了一下，目前的介面完全沒考量到行動裝置直式螢幕，標題與關鍵字欄位跑版不說，結果表格寬度超出螢幕，需要上下左右滑，一整個不專業。</p> <p><img src="https://blog.darkthread.net/Posts/files/2025/Fig1_638959640318920496.jpg" alt="thumbnail"></p> <p>我不想為手機版另外設計一套排版，希望依據寬度切換樣式就能輕鬆搞定，但我的前端技能只有半調子，對 RWD 也沒啥研究... 以前走到這步通常要卡關卡很久，但現在有 Github Copilot 在手，相當於有精通前端設計的神隊友，這樣還搞砸神仙難救!</p> <p>Copilot 給了三種建議：改為卡片式佈局(Card Layout)、加上水平捲軸、隱藏次要欄位縮短寬度，在我的經驗裡卡片式佈局應是最專業最常見的設計方式，也是 Copilot 最推薦的做法。</p> <p>然後，用點小技巧，TABLD/TR/TD 結構可以完全不用動。主要原理是使用 <code>@media (max-width: 768px)</code> 針對寬度 768px 以下改用另一組樣式，有幾個重點：</p> <ul><li>上方標題及文字欄位改用 flex 直式排列</li> <li>將 table, tr, td 都改成 display: block</li> <li>tbody 設定 <code>display: grid</code>，讓 tr 以網格排列，配合 <code>grid-template-columns: repeat(2, 1fr);</code> (重複兩次，每次 1 fraction unit) 設定兩欄</li> <li>英文改藍字、字型加大、粗體</li> <li>英文以外的中文 td，設定 <code>td::before</code> 在前方用 <code>content: attr(data-label)</code> 顯示 data-label Attribute 值 (zh-tw|zh-cn|zh-hk|zh-sg|zh-mo|zh-my)</li> <li>zh-tw/zh-cn 以外的中文 td 用 Vue <code>:class="{'empty': !term.hk}"</code> 設定沒有內容時加上 empty 樣式，再將 .empty 設成 display: none 隱藏</li></ul> <pre><code>/* 寬度小於 768px 時啟用卡片式佈局 */
@media (max-width: 768px) {
header {
/* 改為直向排列 */
flex-direction: column;
align-items: flex-start;
gap: 10px;
h1 {
font-size: 1.3em;
margin: 0;
}
/* 說明連結改為右上角 */
.doc {
position: absolute;
top: 6px;
right: 12px;
z-index: 100;
}
}
/* 參照來源位置微調 */
.content .ref {
margin-top: 12px;
text-align: left;
font-size: 80%;
}
/* 隱藏表格標題列 */
table thead {
display: none;
}
/* 將表格、列與欄都轉換為 Block 排版 */
table {
display: block;
tbody, tr, td {
display: block;
}
}
/* tr 使用 Grid 佈局，並設定成兩欄顯示 */
table tbody {
display: grid;
grid-template-columns: repeat(2, 1fr);
gap: 12px;
}
/* tr 樣式設計成一張卡片 */
table tr {
margin-bottom: 0;
border: 2px solid #ddd;
border-radius: 8px;
padding: 12px;
background: white;
box-shadow: 0 1px 1px rgba(0, 0, 0, 0.5);
}
table td {
border: none;
padding: 2px 0;
text-align: left;
position: relative;
padding-left: 64px;
min-height: 1.2em;
}
/* 在每個儲存格前顯示欄位標籤 */
table td::before {
content: attr(data-label);
position: absolute;
left: 0;
width: 64px;
font-weight: bold;
color: #666;
font-size: 0.9em;
}
/* 英文欄位：藍色、字體放大、粗體 */
table td.en {
font-size: 1.1em;
font-weight: bold;
padding-left: 0;
padding-bottom: 8px;
margin-bottom: 8px;
border-bottom: 1px solid #eee;
/* 前方不需標籤 */
&amp;::before {
display: none;
}
}
/* 針對相同值樣式調整 */
table tr.same td.tw,
table tr.same td.cn {
opacity: 0.5;
font-style: italic;
}
/* 隱藏空白欄位(zh-hk...) */
table td.empty {
display: none;
}
}
</code></pre> <p>嗯，不能跟專業設計比，但比表格好看好用多了。 <a href="https://darkthread.github.io/comp-terms/">中文計算機術語速查工具</a></p> <p><img src="https://blog.darkthread.net/Posts/files/2025/Fig3_638959640322515830.jpg"></p> <p data-slug="wide-table-rwd" data-title-en="Showing wide table on mobile screen" data-catg="Web Development" data-fbimg="https://cdn.pixabay.com/photo/2016/11/22/23/40/hands-1851218_1280.jpg#1280#720">Improved the Chinese IT term lookup tool’s mobile layout with responsive card-style design using CSS media queries, enhancing readability and usability on smartphones.</p>]]></content:encoded>
    <itunes:image href="https://blog.darkthread.net/Posts/files/2025/Fig2_638959640315157964.png"/>
          <media:content url="https://blog.darkthread.net/Posts/files/2025/Fig2_638959640315157964.png" medium="image"/>
    <pubDate>Mon, 13 Oct 2025 14:52:31 GMT</pubDate>
  </item><item>
    <title><![CDATA[Github Copilot 聊天視窗指令整理]]></title>
    <link>https://blog.darkthread.net/blog/copilot-chat-cheatsheet/</link>
    <itunes:title><![CDATA[Github Copilot 聊天視窗指令整理]]></itunes:title>
    <itunes:author><![CDATA[service@darkthread.net (Jeffrey Lee)]]></itunes:author>
    <itunes:summary>
      <![CDATA[<p>使用 VSCode Github Copilot Chat 視窗跟副駕駛聊天時，善用一些特殊指令語法可讓你事半功倍，我老記不住(另一方面也因為人老了更記不住)，寫篇筆記備忘。</p> <p>【主要參考資料】</p> <ul><li><a href="https://docs.github.com/en/copilot/reference/cheat-sheet">GitHub Copilot Chat cheat sheet</a></li> <li><a href="https://code.visualstudio.com/docs/copilot/chat/copilot-chat-context">Github Copilot Chat / Chat / Manage context for AI</a></li></ul> <h2>聊天參與者（Chat Participants）</h2> <p>拉入聊天參與者，內建專家能提供特定領域的協助。使用 <code>@</code> 可指定參與者名稱。</p> <ul><li><code>@azure</code> | 提供 Azure 服務相關使用、部署與管理協助（目前為公開預覽）</li> <li><code>@github</code> | 使用 GitHub 專屬 Copilot 技能</li> <li><code>@terminal</code> | 提供 VS Code 終端機指令相關協助</li> <li><code>@vscode</code> | 提供 VS Code 指令與功能相關協助</li> <li><code>@workspace</code> | 根據工作區程式碼提供結構、互動與設計模式建議</li></ul> <h2>斜線指令（Slash Commands）</h2> <p><code>/</code> 指令可快速執行指定動作，有些指令可能多個參與者都有提供(例如：/explain @workspace 跟 @terminal 都有)，使用時可在前方加註。</p> <ul><li><code>/clear</code> | 清空視窗現有對話，重新開始新的聊天對話</li> <li><code>/explain</code> | 解釋目前編輯器中的程式碼 (小技巧: <code>/explain in zh-tw</code> 可要求 Copilot 說中文)<br> 例：<code>@workspace /explain 金鑰長度在哪裡決定</code> 解釋目前使用中編輯視窗的程式碼、<code>@terminal /explain 錯誤訊息是什麼意思？</code> 讀終端機(Terminal )視窗的文字進行解釋</li> <li><code>/fix</code> | 提出選取程式碼的修正建議</li> <li><code>/fixTestFailure</code> | 找出並修正失敗的測試</li> <li><code>/help</code> | 顯示 Copilot 基本使用說明</li> <li><code>/new</code> | 建立新專案或新檔案<br> 例：<code>/new README.md</code> (會自動補上 @workspace)、<code>/new python django 網站</code> 依要求試著建立專案，可先預覽生成結果<br> <img src="https://blog.darkthread.net/Posts/files/2025/Fig1_638958406470543004.png"></li> <li><code>/newNotebook</code> | 建立 Jupyter Notebook</li> <li><code>/tests</code> | 為選取程式碼產生單元測試</li> <li><code>/setupTests</code> | 為專案產生自動測試</li> <li><code>/search</code> | 用自然語言描述要找什麼，Copilot 幫你想在 VSCode 搜尋的關鍵字</li> <li><code>/startDebugging</code> | 產生 launch.json、tasks.json 等設定檔以進行偵錯</li> <li><code>/list</code> | 列出可用的 Copilot 工具(可供 Copilot 呼叫完成任務)</li></ul> <h2>聊天變數（Chat Variables）</h2> <p>Copilot Chat 輸入欄會自動帶入你正在編輯的檔案、選取的行數範圍，旁邊有 【Add Context...】 鈕可以選取增加，但有時更快的做法是用 <code>#</code> 變數在提示中加入特定上下文。</p> <p><img src="https://blog.darkthread.net/Posts/files/2025/Fig3_638958406472210243.png"></p> <p>一些常用的 # 變數如下：</p> <ul><li><code>#block</code> | 包含目前程式碼區塊</li> <li><code>#class</code> | 包含目前類別</li> <li><code>#comment</code> | 包含目前註解</li> <li><code>#&lt;file_name&gt;</code> | #直接加檔名，把檔案內容包含進來(若程式檔太大，Copilot 會彙總成函式清單及說明，若還是放不下就放棄) 例如：<code>Add a login button and style it based on #styles.css</code></li> <li><code>#&lt;symbol_name&gt;</code> | #也可用來指定方法、函式或變數名稱，配合 #usages 可以搜尋它在工作區被引用的位置<br> 例如：<code>Where is #getUser used? #usages</code></li> <li><code>#line</code> | 包含目前程式碼行</li> <li><code>#project</code> | 包含專案上下文</li> <li><code>#selection</code> | 包含目前選取文字</li> <li><code>#changes</code> | 包含目前的 Git Changes</li> <li><code>#codebase</code> | 執行完整程式碼庫搜尋，自動找到相關檔案和符號</li> <li><code>#editor</code> | 包含目前編輯器的上下文資訊</li> <li><code>#problems</code> | 引用 Problems 面板(如下圖)中的問題作為上下文<br> <img src="https://blog.darkthread.net/Posts/files/2025/Fig2_638958406473924269.png"></li> <li><code>#testFailure</code> | 引用測試失敗的相關資訊</li> <li><code>#terminal</code> | 包含終端機輸出或相關內容</li> <li><code>#fetch</code> | 從指定網頁下載內容作為上下文 例如：<code>#fetch https://petstore.swagger.io/#/ 產生 PUT /pet 範例</code> (連網前會先徵求同意)</li> <li><code>#githubRepo</code> | 在指定的 GitHub 儲存庫中執行程式碼搜尋<br> <code>Build an API endpoint to fetch address info, use the template from #githubRepo contoso/api-templates"</code></li></ul> <p data-slug="copilot-chat-cheatsheet" data-fbimg="https://i.postimg.cc/YSRhHLkS/image.png#1248#702"> </p>]]>
    </itunes:summary>
    <description>
      <![CDATA[<p>使用 VSCode Github Copilot Chat 視窗跟副駕駛聊天時，善用一些特殊指令語法可讓你事半功倍，我老記不住(另一方面也因為人老了更記不住)，寫篇筆記備忘。</p> <p>【主要參考資料】</p> <ul><li><a href="https://docs.github.com/en/copilot/reference/cheat-sheet">GitHub Copilot Chat cheat sheet</a></li> <li><a href="https://code.visualstudio.com/docs/copilot/chat/copilot-chat-context">Github Copilot Chat / Chat / Manage context for AI</a></li></ul> <h2>聊天參與者（Chat Participants）</h2> <p>拉入聊天參與者，內建專家能提供特定領域的協助。使用 <code>@</code> 可指定參與者名稱。</p> <ul><li><code>@azure</code> | 提供 Azure 服務相關使用、部署與管理協助（目前為公開預覽）</li> <li><code>@github</code> | 使用 GitHub 專屬 Copilot 技能</li> <li><code>@terminal</code> | 提供 VS Code 終端機指令相關協助</li> <li><code>@vscode</code> | 提供 VS Code 指令與功能相關協助</li> <li><code>@workspace</code> | 根據工作區程式碼提供結構、互動與設計模式建議</li></ul> <h2>斜線指令（Slash Commands）</h2> <p><code>/</code> 指令可快速執行指定動作，有些指令可能多個參與者都有提供(例如：/explain @workspace 跟 @terminal 都有)，使用時可在前方加註。</p> <ul><li><code>/clear</code> | 清空視窗現有對話，重新開始新的聊天對話</li> <li><code>/explain</code> | 解釋目前編輯器中的程式碼 (小技巧: <code>/explain in zh-tw</code> 可要求 Copilot 說中文)<br> 例：<code>@workspace /explain 金鑰長度在哪裡決定</code> 解釋目前使用中編輯視窗的程式碼、<code>@terminal /explain 錯誤訊息是什麼意思？</code> 讀終端機(Terminal )視窗的文字進行解釋</li> <li><code>/fix</code> | 提出選取程式碼的修正建議</li> <li><code>/fixTestFailure</code> | 找出並修正失敗的測試</li> <li><code>/help</code> | 顯示 Copilot 基本使用說明</li> <li><code>/new</code> | 建立新專案或新檔案<br> 例：<code>/new README.md</code> (會自動補上 @workspace)、<code>/new python django 網站</code> 依要求試著建立專案，可先預覽生成結果<br> <img src="https://blog.darkthread.net/Posts/files/2025/Fig1_638958406470543004.png"></li> <li><code>/newNotebook</code> | 建立 Jupyter Notebook</li> <li><code>/tests</code> | 為選取程式碼產生單元測試</li> <li><code>/setupTests</code> | 為專案產生自動測試</li> <li><code>/search</code> | 用自然語言描述要找什麼，Copilot 幫你想在 VSCode 搜尋的關鍵字</li> <li><code>/startDebugging</code> | 產生 launch.json、tasks.json 等設定檔以進行偵錯</li> <li><code>/list</code> | 列出可用的 Copilot 工具(可供 Copilot 呼叫完成任務)</li></ul> <h2>聊天變數（Chat Variables）</h2> <p>Copilot Chat 輸入欄會自動帶入你正在編輯的檔案、選取的行數範圍，旁邊有 【Add Context...】 鈕可以選取增加，但有時更快的做法是用 <code>#</code> 變數在提示中加入特定上下文。</p> <p><img src="https://blog.darkthread.net/Posts/files/2025/Fig3_638958406472210243.png"></p> <p>一些常用的 # 變數如下：</p> <ul><li><code>#block</code> | 包含目前程式碼區塊</li> <li><code>#class</code> | 包含目前類別</li> <li><code>#comment</code> | 包含目前註解</li> <li><code>#&lt;file_name&gt;</code> | #直接加檔名，把檔案內容包含進來(若程式檔太大，Copilot 會彙總成函式清單及說明，若還是放不下就放棄) 例如：<code>Add a login button and style it based on #styles.css</code></li> <li><code>#&lt;symbol_name&gt;</code> | #也可用來指定方法、函式或變數名稱，配合 #usages 可以搜尋它在工作區被引用的位置<br> 例如：<code>Where is #getUser used? #usages</code></li> <li><code>#line</code> | 包含目前程式碼行</li> <li><code>#project</code> | 包含專案上下文</li> <li><code>#selection</code> | 包含目前選取文字</li> <li><code>#changes</code> | 包含目前的 Git Changes</li> <li><code>#codebase</code> | 執行完整程式碼庫搜尋，自動找到相關檔案和符號</li> <li><code>#editor</code> | 包含目前編輯器的上下文資訊</li> <li><code>#problems</code> | 引用 Problems 面板(如下圖)中的問題作為上下文<br> <img src="https://blog.darkthread.net/Posts/files/2025/Fig2_638958406473924269.png"></li> <li><code>#testFailure</code> | 引用測試失敗的相關資訊</li> <li><code>#terminal</code> | 包含終端機輸出或相關內容</li> <li><code>#fetch</code> | 從指定網頁下載內容作為上下文 例如：<code>#fetch https://petstore.swagger.io/#/ 產生 PUT /pet 範例</code> (連網前會先徵求同意)</li> <li><code>#githubRepo</code> | 在指定的 GitHub 儲存庫中執行程式碼搜尋<br> <code>Build an API endpoint to fetch address info, use the template from #githubRepo contoso/api-templates"</code></li></ul> <p data-slug="copilot-chat-cheatsheet" data-fbimg="https://i.postimg.cc/YSRhHLkS/image.png#1248#702"> </p>]]>
    </description>
    <content:encoded><![CDATA[<p>使用 VSCode Github Copilot Chat 視窗跟副駕駛聊天時，善用一些特殊指令語法可讓你事半功倍，我老記不住(另一方面也因為人老了更記不住)，寫篇筆記備忘。</p> <p>【主要參考資料】</p> <ul><li><a href="https://docs.github.com/en/copilot/reference/cheat-sheet">GitHub Copilot Chat cheat sheet</a></li> <li><a href="https://code.visualstudio.com/docs/copilot/chat/copilot-chat-context">Github Copilot Chat / Chat / Manage context for AI</a></li></ul> <h2>聊天參與者（Chat Participants）</h2> <p>拉入聊天參與者，內建專家能提供特定領域的協助。使用 <code>@</code> 可指定參與者名稱。</p> <ul><li><code>@azure</code> | 提供 Azure 服務相關使用、部署與管理協助（目前為公開預覽）</li> <li><code>@github</code> | 使用 GitHub 專屬 Copilot 技能</li> <li><code>@terminal</code> | 提供 VS Code 終端機指令相關協助</li> <li><code>@vscode</code> | 提供 VS Code 指令與功能相關協助</li> <li><code>@workspace</code> | 根據工作區程式碼提供結構、互動與設計模式建議</li></ul> <h2>斜線指令（Slash Commands）</h2> <p><code>/</code> 指令可快速執行指定動作，有些指令可能多個參與者都有提供(例如：/explain @workspace 跟 @terminal 都有)，使用時可在前方加註。</p> <ul><li><code>/clear</code> | 清空視窗現有對話，重新開始新的聊天對話</li> <li><code>/explain</code> | 解釋目前編輯器中的程式碼 (小技巧: <code>/explain in zh-tw</code> 可要求 Copilot 說中文)<br> 例：<code>@workspace /explain 金鑰長度在哪裡決定</code> 解釋目前使用中編輯視窗的程式碼、<code>@terminal /explain 錯誤訊息是什麼意思？</code> 讀終端機(Terminal )視窗的文字進行解釋</li> <li><code>/fix</code> | 提出選取程式碼的修正建議</li> <li><code>/fixTestFailure</code> | 找出並修正失敗的測試</li> <li><code>/help</code> | 顯示 Copilot 基本使用說明</li> <li><code>/new</code> | 建立新專案或新檔案<br> 例：<code>/new README.md</code> (會自動補上 @workspace)、<code>/new python django 網站</code> 依要求試著建立專案，可先預覽生成結果<br> <img src="https://blog.darkthread.net/Posts/files/2025/Fig1_638958406470543004.png"></li> <li><code>/newNotebook</code> | 建立 Jupyter Notebook</li> <li><code>/tests</code> | 為選取程式碼產生單元測試</li> <li><code>/setupTests</code> | 為專案產生自動測試</li> <li><code>/search</code> | 用自然語言描述要找什麼，Copilot 幫你想在 VSCode 搜尋的關鍵字</li> <li><code>/startDebugging</code> | 產生 launch.json、tasks.json 等設定檔以進行偵錯</li> <li><code>/list</code> | 列出可用的 Copilot 工具(可供 Copilot 呼叫完成任務)</li></ul> <h2>聊天變數（Chat Variables）</h2> <p>Copilot Chat 輸入欄會自動帶入你正在編輯的檔案、選取的行數範圍，旁邊有 【Add Context...】 鈕可以選取增加，但有時更快的做法是用 <code>#</code> 變數在提示中加入特定上下文。</p> <p><img src="https://blog.darkthread.net/Posts/files/2025/Fig3_638958406472210243.png"></p> <p>一些常用的 # 變數如下：</p> <ul><li><code>#block</code> | 包含目前程式碼區塊</li> <li><code>#class</code> | 包含目前類別</li> <li><code>#comment</code> | 包含目前註解</li> <li><code>#&lt;file_name&gt;</code> | #直接加檔名，把檔案內容包含進來(若程式檔太大，Copilot 會彙總成函式清單及說明，若還是放不下就放棄) 例如：<code>Add a login button and style it based on #styles.css</code></li> <li><code>#&lt;symbol_name&gt;</code> | #也可用來指定方法、函式或變數名稱，配合 #usages 可以搜尋它在工作區被引用的位置<br> 例如：<code>Where is #getUser used? #usages</code></li> <li><code>#line</code> | 包含目前程式碼行</li> <li><code>#project</code> | 包含專案上下文</li> <li><code>#selection</code> | 包含目前選取文字</li> <li><code>#changes</code> | 包含目前的 Git Changes</li> <li><code>#codebase</code> | 執行完整程式碼庫搜尋，自動找到相關檔案和符號</li> <li><code>#editor</code> | 包含目前編輯器的上下文資訊</li> <li><code>#problems</code> | 引用 Problems 面板(如下圖)中的問題作為上下文<br> <img src="https://blog.darkthread.net/Posts/files/2025/Fig2_638958406473924269.png"></li> <li><code>#testFailure</code> | 引用測試失敗的相關資訊</li> <li><code>#terminal</code> | 包含終端機輸出或相關內容</li> <li><code>#fetch</code> | 從指定網頁下載內容作為上下文 例如：<code>#fetch https://petstore.swagger.io/#/ 產生 PUT /pet 範例</code> (連網前會先徵求同意)</li> <li><code>#githubRepo</code> | 在指定的 GitHub 儲存庫中執行程式碼搜尋<br> <code>Build an API endpoint to fetch address info, use the template from #githubRepo contoso/api-templates"</code></li></ul> <p data-slug="copilot-chat-cheatsheet" data-fbimg="https://i.postimg.cc/YSRhHLkS/image.png#1248#702"> </p>]]></content:encoded>
    <itunes:image href="https://blog.darkthread.net/Posts/files/2025/Fig1_638958406470543004.png"/>
          <media:content url="https://blog.darkthread.net/Posts/files/2025/Fig1_638958406470543004.png" medium="image"/>
    <pubDate>Sun, 12 Oct 2025 04:30:21 GMT</pubDate>
  </item><item>
    <title><![CDATA[「中文計算機術語速查工具」上線啦~]]></title>
    <link>https://blog.darkthread.net/blog/chinese-it-term-translation-instant-lookup/</link>
    <itunes:title><![CDATA[「中文計算機術語速查工具」上線啦~]]></itunes:title>
    <itunes:author><![CDATA[service@darkthread.net (Jeffrey Lee)]]></itunes:author>
    <itunes:summary>
      <![CDATA[<p>這大概是為了喝牛奶養一頭牛的典型案例吧... (笑)</p> <p>許多計算機相關術語，繁體與簡體翻譯及慣用說法不同，有些不難識別，像是記憶體/內存、陣列/數組、影片/視頻... 大家耳熟能詳，但有些如外掛/插件、繫結/綁定、死結/死鎖、回饋/反饋就不是那麼一望便知。至於「行」與「列」則是進入一個「你的列是我的行、你的行是我的列」的奇妙境界... XD (延伸閱讀：<a href="/blog/row-column-translation/">直行橫列？直列橫行？</a>)</p> <p>在我的觀念，語言是溝通工具，用字遣詞讓雙方能懂不生誤會就好，我不會堅持一定得用標準說法。不過有時還是會好奇某個電腦術語在台灣的正確翻譯，最近一個例子是 <a href="/blog/fp-vs-oop/">Functional Programming 是否會取代 OOP</a> 文章提到 High Concurrency，我至少看過三種講法：「高併發」、「高並發」、「高並行」。依據國語辭典，<a href="https://dict.revised.moe.edu.tw/dictView.jsp?ID=19762&amp;la=0&amp;powerMode=0">並行</a> (並排行走/同時進行)、<a href="https://dict.revised.moe.edu.tw/dictView.jsp?ID=19706&amp;q=1&amp;word=%E4%B8%A6%E7%99%BC"></a> (同時發生)應該都講得通，而「高並發」可能是直翻簡體「高并发」，國語辭典查不到「並發」這種寫法。(「<a href="https://dict.concised.moe.edu.tw/dictView.jsp?ID=1801&amp;la=0&amp;powerMode=0">并</a>」字通「併」也通「並」)</p> <p>為了求證，我查了幾個來源：</p> <ul><li><a href="https://zh.wikibooks.org/zh-tw/%E5%A4%A7%E9%99%86%E5%8F%B0%E6%B9%BE%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9C%AF%E8%AF%AD%E5%AF%B9%E7%85%A7%E8%A1%A8">維基教科書：大陸台灣計算機術語對照表</a> Concurrency = 並行性，並行</li> <li><a href="http://www.iicm.org.tw/term/termb_C.htm">電腦名詞譯名</a> concurrency = 同作；並行</li> <li><a href="https://zh.wikipedia.org/wiki/Module:CGroup/IT">維基百科/資訊科技公共轉換組</a> concurrency = 並行</li></ul> <p>3:0，正確答案揭曉：Concurrency 公認的正統台灣翻譯應為「並行」。</p> <p>類似需求都要這樣查或丟給 LLM 翻譯有點沒效率，於是我想寫個能用關鍵字快速查詢的網頁介面，像是這樣：</p> <p><img src="https://blog.darkthread.net/Posts/files/2025/Fig1_638957873486756323.png"></p> <p>研究了一下，維基百科的字詞轉換處理/公共轉換組資料感覺是不錯的來源。第一是維基百科本身具備一定權威性，翻譯出錯會有社群機制修正，而其相關詞庫涵蓋 IT、遊戲、Apple/Microsoft 作業系統、電子、通訊... 等，超過 1400 條挺豐富完整，除了 zh-tw、zh-cn、zh-hk，甚至還有少量 zh-sg (新加坡)、zh-mo (澳門)、zh-my (馬來西亞)，還是中文翻釋的大總匯，再加上它提供接近結構化資料的原始碼格式，處理難度最低，就決定是它了。</p> <p><img src="https://blog.darkthread.net/Posts/files/2025/Fig2_638957873489935591.png"></p> <p>不過我很快發現公共轉換組少了一些很基本的計算機術語，例如：Copy、Domain、Pseudo Code... 就再花了一點時間把「大陸台灣計算機術語對照表」的四百多條也整合進去(這類匯入工具是適合 Vibe Coding 的經典應用，我順勢享受泡杯茶等 Copilot 把程式改到好的神奇體驗，如下圖)，用不高的成本捏出一個勉強及格的計算機相關中文術語庫。</p> <p><img src="https://blog.darkthread.net/Posts/files/2025/Fig4_638957873493101988.png" alt="thumbnail"></p> <p>程式不複雜，只要有心不難用 AI 刻一個，就不花篇幅貼原始碼了，查詢網頁我已放上 Github Page - <a href="https://darkthread.github.io/comp-terms/">中文計算機術語速查工具</a>，需要牛奶的朋友請自取。</p> <p><img src="https://blog.darkthread.net/Posts/files/2025/Fig3_638957873495650411.png"></p> <p>至對養牛有興趣的同學，以下是我覺得值得分享的技術細節，並一併附上<a href="https://github.com/darkthread/darkthread.github.io/blob/master/comp-terms/index.html">原始碼</a>：</p> <ul><li>介面我是用 Vue.js MVVM 寫法，但採輕前端風格，不用 TypeScript，不需要 npm，不必編譯，HTML <code>&lt;script src="https://unpkg.com/vue@3"&gt;&lt;/script&gt;</code> 載入 Vue.js 程式庫，寫幾行 JavaScript 搞定，這是我目前最愛的前端開發方式，適合無暇投入大多時間鑽究前端的全端攻城獅。<br> 參考：<a href="/blog/vue-mvvm-tutorial/">體驗美妙的輕前端 MVVM - Vue.js 入門教學資源</a></li> <li>輸入關鍵字元即時顯示查詢結果的範例我寫過很多，它的操作體驗比打完按 Enter 查好很多，但易有輸入過程顯示大量非查詢對象及畫面過度閃動問題，我是使用 Debounce 技巧克服。<br> 參考：<a href="/blog/vue-model-debounce/">Vue 練習：關鍵字即時查詢之去抖動(Debounce)處理</a></li> <li>Vue 顯示表格遇筆數過多時易有卡頓、畫面短暫空白問題，本次的案例不到 1500 筆，卡頓空白情況還算輕微，就不搬出虛擬捲動 (Virtual Scrolling) 這把牛刀了。<br> 參考：<a href="/blog/virtual-scrolling/">前端練習 - 讓數十萬筆的超大表格也能流暢捲動</a></li> <li>關鍵字輸入欄位自帶 X 鈕可清空輸入文字，用的是昨天提到自己捏的原生客製 HTML 元素，支援 Vue v-model 資料繫結。<br> 參考：<a href="/blog/cust-html-input-element-w-v-model/">手捏支援 Vue v-model 的可清除文字輸入框</a></li> <li>我寫了 PowerShell，使用 Regular Expression 從 ‵Item('computer', '电子计算机=&gt;zh-sg:电脑; 电子计算机=&gt;zh-my:电脑; 电子计算机=&gt;zh-tw:電腦; 电子计算机=&gt;zh-hk:電腦; 电子计算机=&gt;zh-mo:電腦;'),` 取出各語系的對應翻譯，有些詞條只有 zh-hant 及 zh-hans，我的做法是將其視為 zh-tw 及 zh-cn。同一英文出現多次時，先去取重複者再使用 ; 合併。</li> <li>匯入的維基詞條我人工做了簡單篩選，拿掉一些公司或機關名稱，以及 drive - D drive / 本機磁碟(D) 這類瑣碎名詞，但篩得很隨興，不保證品質。</li></ul> <p data-slug="chinese-it-term-translation-instant-lookup" data-title-en="Chinese IT terminology translation" data-catg="Web Development" data-fbimg="">Introduced a quick search tool for Chinese IT terminology translations, leveraging Wikipedia’s public conversion data and Vue.js for a lightweight, instant lookup interface.</p>]]>
    </itunes:summary>
    <description>
      <![CDATA[<p>這大概是為了喝牛奶養一頭牛的典型案例吧... (笑)</p> <p>許多計算機相關術語，繁體與簡體翻譯及慣用說法不同，有些不難識別，像是記憶體/內存、陣列/數組、影片/視頻... 大家耳熟能詳，但有些如外掛/插件、繫結/綁定、死結/死鎖、回饋/反饋就不是那麼一望便知。至於「行」與「列」則是進入一個「你的列是我的行、你的行是我的列」的奇妙境界... XD (延伸閱讀：<a href="/blog/row-column-translation/">直行橫列？直列橫行？</a>)</p> <p>在我的觀念，語言是溝通工具，用字遣詞讓雙方能懂不生誤會就好，我不會堅持一定得用標準說法。不過有時還是會好奇某個電腦術語在台灣的正確翻譯，最近一個例子是 <a href="/blog/fp-vs-oop/">Functional Programming 是否會取代 OOP</a> 文章提到 High Concurrency，我至少看過三種講法：「高併發」、「高並發」、「高並行」。依據國語辭典，<a href="https://dict.revised.moe.edu.tw/dictView.jsp?ID=19762&amp;la=0&amp;powerMode=0">並行</a> (並排行走/同時進行)、<a href="https://dict.revised.moe.edu.tw/dictView.jsp?ID=19706&amp;q=1&amp;word=%E4%B8%A6%E7%99%BC"></a> (同時發生)應該都講得通，而「高並發」可能是直翻簡體「高并发」，國語辭典查不到「並發」這種寫法。(「<a href="https://dict.concised.moe.edu.tw/dictView.jsp?ID=1801&amp;la=0&amp;powerMode=0">并</a>」字通「併」也通「並」)</p> <p>為了求證，我查了幾個來源：</p> <ul><li><a href="https://zh.wikibooks.org/zh-tw/%E5%A4%A7%E9%99%86%E5%8F%B0%E6%B9%BE%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9C%AF%E8%AF%AD%E5%AF%B9%E7%85%A7%E8%A1%A8">維基教科書：大陸台灣計算機術語對照表</a> Concurrency = 並行性，並行</li> <li><a href="http://www.iicm.org.tw/term/termb_C.htm">電腦名詞譯名</a> concurrency = 同作；並行</li> <li><a href="https://zh.wikipedia.org/wiki/Module:CGroup/IT">維基百科/資訊科技公共轉換組</a> concurrency = 並行</li></ul> <p>3:0，正確答案揭曉：Concurrency 公認的正統台灣翻譯應為「並行」。</p> <p>類似需求都要這樣查或丟給 LLM 翻譯有點沒效率，於是我想寫個能用關鍵字快速查詢的網頁介面，像是這樣：</p> <p><img src="https://blog.darkthread.net/Posts/files/2025/Fig1_638957873486756323.png"></p> <p>研究了一下，維基百科的字詞轉換處理/公共轉換組資料感覺是不錯的來源。第一是維基百科本身具備一定權威性，翻譯出錯會有社群機制修正，而其相關詞庫涵蓋 IT、遊戲、Apple/Microsoft 作業系統、電子、通訊... 等，超過 1400 條挺豐富完整，除了 zh-tw、zh-cn、zh-hk，甚至還有少量 zh-sg (新加坡)、zh-mo (澳門)、zh-my (馬來西亞)，還是中文翻釋的大總匯，再加上它提供接近結構化資料的原始碼格式，處理難度最低，就決定是它了。</p> <p><img src="https://blog.darkthread.net/Posts/files/2025/Fig2_638957873489935591.png"></p> <p>不過我很快發現公共轉換組少了一些很基本的計算機術語，例如：Copy、Domain、Pseudo Code... 就再花了一點時間把「大陸台灣計算機術語對照表」的四百多條也整合進去(這類匯入工具是適合 Vibe Coding 的經典應用，我順勢享受泡杯茶等 Copilot 把程式改到好的神奇體驗，如下圖)，用不高的成本捏出一個勉強及格的計算機相關中文術語庫。</p> <p><img src="https://blog.darkthread.net/Posts/files/2025/Fig4_638957873493101988.png" alt="thumbnail"></p> <p>程式不複雜，只要有心不難用 AI 刻一個，就不花篇幅貼原始碼了，查詢網頁我已放上 Github Page - <a href="https://darkthread.github.io/comp-terms/">中文計算機術語速查工具</a>，需要牛奶的朋友請自取。</p> <p><img src="https://blog.darkthread.net/Posts/files/2025/Fig3_638957873495650411.png"></p> <p>至對養牛有興趣的同學，以下是我覺得值得分享的技術細節，並一併附上<a href="https://github.com/darkthread/darkthread.github.io/blob/master/comp-terms/index.html">原始碼</a>：</p> <ul><li>介面我是用 Vue.js MVVM 寫法，但採輕前端風格，不用 TypeScript，不需要 npm，不必編譯，HTML <code>&lt;script src="https://unpkg.com/vue@3"&gt;&lt;/script&gt;</code> 載入 Vue.js 程式庫，寫幾行 JavaScript 搞定，這是我目前最愛的前端開發方式，適合無暇投入大多時間鑽究前端的全端攻城獅。<br> 參考：<a href="/blog/vue-mvvm-tutorial/">體驗美妙的輕前端 MVVM - Vue.js 入門教學資源</a></li> <li>輸入關鍵字元即時顯示查詢結果的範例我寫過很多，它的操作體驗比打完按 Enter 查好很多，但易有輸入過程顯示大量非查詢對象及畫面過度閃動問題，我是使用 Debounce 技巧克服。<br> 參考：<a href="/blog/vue-model-debounce/">Vue 練習：關鍵字即時查詢之去抖動(Debounce)處理</a></li> <li>Vue 顯示表格遇筆數過多時易有卡頓、畫面短暫空白問題，本次的案例不到 1500 筆，卡頓空白情況還算輕微，就不搬出虛擬捲動 (Virtual Scrolling) 這把牛刀了。<br> 參考：<a href="/blog/virtual-scrolling/">前端練習 - 讓數十萬筆的超大表格也能流暢捲動</a></li> <li>關鍵字輸入欄位自帶 X 鈕可清空輸入文字，用的是昨天提到自己捏的原生客製 HTML 元素，支援 Vue v-model 資料繫結。<br> 參考：<a href="/blog/cust-html-input-element-w-v-model/">手捏支援 Vue v-model 的可清除文字輸入框</a></li> <li>我寫了 PowerShell，使用 Regular Expression 從 ‵Item('computer', '电子计算机=&gt;zh-sg:电脑; 电子计算机=&gt;zh-my:电脑; 电子计算机=&gt;zh-tw:電腦; 电子计算机=&gt;zh-hk:電腦; 电子计算机=&gt;zh-mo:電腦;'),` 取出各語系的對應翻譯，有些詞條只有 zh-hant 及 zh-hans，我的做法是將其視為 zh-tw 及 zh-cn。同一英文出現多次時，先去取重複者再使用 ; 合併。</li> <li>匯入的維基詞條我人工做了簡單篩選，拿掉一些公司或機關名稱，以及 drive - D drive / 本機磁碟(D) 這類瑣碎名詞，但篩得很隨興，不保證品質。</li></ul> <p data-slug="chinese-it-term-translation-instant-lookup" data-title-en="Chinese IT terminology translation" data-catg="Web Development" data-fbimg="">Introduced a quick search tool for Chinese IT terminology translations, leveraging Wikipedia’s public conversion data and Vue.js for a lightweight, instant lookup interface.</p>]]>
    </description>
    <content:encoded><![CDATA[<p>這大概是為了喝牛奶養一頭牛的典型案例吧... (笑)</p> <p>許多計算機相關術語，繁體與簡體翻譯及慣用說法不同，有些不難識別，像是記憶體/內存、陣列/數組、影片/視頻... 大家耳熟能詳，但有些如外掛/插件、繫結/綁定、死結/死鎖、回饋/反饋就不是那麼一望便知。至於「行」與「列」則是進入一個「你的列是我的行、你的行是我的列」的奇妙境界... XD (延伸閱讀：<a href="/blog/row-column-translation/">直行橫列？直列橫行？</a>)</p> <p>在我的觀念，語言是溝通工具，用字遣詞讓雙方能懂不生誤會就好，我不會堅持一定得用標準說法。不過有時還是會好奇某個電腦術語在台灣的正確翻譯，最近一個例子是 <a href="/blog/fp-vs-oop/">Functional Programming 是否會取代 OOP</a> 文章提到 High Concurrency，我至少看過三種講法：「高併發」、「高並發」、「高並行」。依據國語辭典，<a href="https://dict.revised.moe.edu.tw/dictView.jsp?ID=19762&amp;la=0&amp;powerMode=0">並行</a> (並排行走/同時進行)、<a href="https://dict.revised.moe.edu.tw/dictView.jsp?ID=19706&amp;q=1&amp;word=%E4%B8%A6%E7%99%BC"></a> (同時發生)應該都講得通，而「高並發」可能是直翻簡體「高并发」，國語辭典查不到「並發」這種寫法。(「<a href="https://dict.concised.moe.edu.tw/dictView.jsp?ID=1801&amp;la=0&amp;powerMode=0">并</a>」字通「併」也通「並」)</p> <p>為了求證，我查了幾個來源：</p> <ul><li><a href="https://zh.wikibooks.org/zh-tw/%E5%A4%A7%E9%99%86%E5%8F%B0%E6%B9%BE%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9C%AF%E8%AF%AD%E5%AF%B9%E7%85%A7%E8%A1%A8">維基教科書：大陸台灣計算機術語對照表</a> Concurrency = 並行性，並行</li> <li><a href="http://www.iicm.org.tw/term/termb_C.htm">電腦名詞譯名</a> concurrency = 同作；並行</li> <li><a href="https://zh.wikipedia.org/wiki/Module:CGroup/IT">維基百科/資訊科技公共轉換組</a> concurrency = 並行</li></ul> <p>3:0，正確答案揭曉：Concurrency 公認的正統台灣翻譯應為「並行」。</p> <p>類似需求都要這樣查或丟給 LLM 翻譯有點沒效率，於是我想寫個能用關鍵字快速查詢的網頁介面，像是這樣：</p> <p><img src="https://blog.darkthread.net/Posts/files/2025/Fig1_638957873486756323.png"></p> <p>研究了一下，維基百科的字詞轉換處理/公共轉換組資料感覺是不錯的來源。第一是維基百科本身具備一定權威性，翻譯出錯會有社群機制修正，而其相關詞庫涵蓋 IT、遊戲、Apple/Microsoft 作業系統、電子、通訊... 等，超過 1400 條挺豐富完整，除了 zh-tw、zh-cn、zh-hk，甚至還有少量 zh-sg (新加坡)、zh-mo (澳門)、zh-my (馬來西亞)，還是中文翻釋的大總匯，再加上它提供接近結構化資料的原始碼格式，處理難度最低，就決定是它了。</p> <p><img src="https://blog.darkthread.net/Posts/files/2025/Fig2_638957873489935591.png"></p> <p>不過我很快發現公共轉換組少了一些很基本的計算機術語，例如：Copy、Domain、Pseudo Code... 就再花了一點時間把「大陸台灣計算機術語對照表」的四百多條也整合進去(這類匯入工具是適合 Vibe Coding 的經典應用，我順勢享受泡杯茶等 Copilot 把程式改到好的神奇體驗，如下圖)，用不高的成本捏出一個勉強及格的計算機相關中文術語庫。</p> <p><img src="https://blog.darkthread.net/Posts/files/2025/Fig4_638957873493101988.png" alt="thumbnail"></p> <p>程式不複雜，只要有心不難用 AI 刻一個，就不花篇幅貼原始碼了，查詢網頁我已放上 Github Page - <a href="https://darkthread.github.io/comp-terms/">中文計算機術語速查工具</a>，需要牛奶的朋友請自取。</p> <p><img src="https://blog.darkthread.net/Posts/files/2025/Fig3_638957873495650411.png"></p> <p>至對養牛有興趣的同學，以下是我覺得值得分享的技術細節，並一併附上<a href="https://github.com/darkthread/darkthread.github.io/blob/master/comp-terms/index.html">原始碼</a>：</p> <ul><li>介面我是用 Vue.js MVVM 寫法，但採輕前端風格，不用 TypeScript，不需要 npm，不必編譯，HTML <code>&lt;script src="https://unpkg.com/vue@3"&gt;&lt;/script&gt;</code> 載入 Vue.js 程式庫，寫幾行 JavaScript 搞定，這是我目前最愛的前端開發方式，適合無暇投入大多時間鑽究前端的全端攻城獅。<br> 參考：<a href="/blog/vue-mvvm-tutorial/">體驗美妙的輕前端 MVVM - Vue.js 入門教學資源</a></li> <li>輸入關鍵字元即時顯示查詢結果的範例我寫過很多，它的操作體驗比打完按 Enter 查好很多，但易有輸入過程顯示大量非查詢對象及畫面過度閃動問題，我是使用 Debounce 技巧克服。<br> 參考：<a href="/blog/vue-model-debounce/">Vue 練習：關鍵字即時查詢之去抖動(Debounce)處理</a></li> <li>Vue 顯示表格遇筆數過多時易有卡頓、畫面短暫空白問題，本次的案例不到 1500 筆，卡頓空白情況還算輕微，就不搬出虛擬捲動 (Virtual Scrolling) 這把牛刀了。<br> 參考：<a href="/blog/virtual-scrolling/">前端練習 - 讓數十萬筆的超大表格也能流暢捲動</a></li> <li>關鍵字輸入欄位自帶 X 鈕可清空輸入文字，用的是昨天提到自己捏的原生客製 HTML 元素，支援 Vue v-model 資料繫結。<br> 參考：<a href="/blog/cust-html-input-element-w-v-model/">手捏支援 Vue v-model 的可清除文字輸入框</a></li> <li>我寫了 PowerShell，使用 Regular Expression 從 ‵Item('computer', '电子计算机=&gt;zh-sg:电脑; 电子计算机=&gt;zh-my:电脑; 电子计算机=&gt;zh-tw:電腦; 电子计算机=&gt;zh-hk:電腦; 电子计算机=&gt;zh-mo:電腦;'),` 取出各語系的對應翻譯，有些詞條只有 zh-hant 及 zh-hans，我的做法是將其視為 zh-tw 及 zh-cn。同一英文出現多次時，先去取重複者再使用 ; 合併。</li> <li>匯入的維基詞條我人工做了簡單篩選，拿掉一些公司或機關名稱，以及 drive - D drive / 本機磁碟(D) 這類瑣碎名詞，但篩得很隨興，不保證品質。</li></ul> <p data-slug="chinese-it-term-translation-instant-lookup" data-title-en="Chinese IT terminology translation" data-catg="Web Development" data-fbimg="">Introduced a quick search tool for Chinese IT terminology translations, leveraging Wikipedia’s public conversion data and Vue.js for a lightweight, instant lookup interface.</p>]]></content:encoded>
    <itunes:image href="https://blog.darkthread.net/Posts/files/2025/Fig1_638957873486756323.png"/>
          <media:content url="https://blog.darkthread.net/Posts/files/2025/Fig1_638957873486756323.png" medium="image"/>
    <pubDate>Sat, 11 Oct 2025 14:28:32 GMT</pubDate>
  </item><item>
    <title><![CDATA[手捏支援 Vue v-model 的可清除文字輸入框]]></title>
    <link>https://blog.darkthread.net/blog/cust-html-input-element-w-v-model/</link>
    <itunes:title><![CDATA[手捏支援 Vue v-model 的可清除文字輸入框]]></itunes:title>
    <itunes:author><![CDATA[service@darkthread.net (Jeffrey Lee)]]></itunes:author>
    <itunes:summary>
      <![CDATA[<p>自從 IE 登出，Trident 版 Edge 被放生，瀏覽器重回大一統時代。有別於前次的 IE 王朝，當今主宰前端的 Chromium 配備的 HTML / JavaScript / CSS 規格完備，功能與二十年前不可同日而語，且會自動更新不用太擔心支援問題，現在寫前端輕鬆許多。</p> <p>2016 加入的<a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_components/Using_custom_elements">自訂 HTML 元素</a>功能深得我心，自訂元素這檔事幾乎所有前端框架都有自己的玩法，我玩過 <a href="/blog/ko-component/">knockout.js</a>、<a href="/blog/angular-notes-23/">AngularJS</a>、<a href="https://vuejs.org/guide/essentials/component-basics">Vue.js</a>，每個都有，甚至早在 IE6 時代，微軟也有自家的網頁元件技術 - .htc <a href="https://learn.microsoft.com/en-us/openspecs/ie_standards/ms-html401e/36bd9386-cd5f-4bfe-8dec-5efc865a689c?WT.mc_id=DOP-MVP-37580">HTML Component</a>。自訂網頁元件，易於設計維護擴充重用，就像在前端 UI 實踐物件導向設計，好處很多。如今瀏覽器原生支援自訂網頁元素，不需依賴任何框架，效能更佳，運用起來更靈活。</p> <p>UI 元素行為封裝成自訂 HTML 元素，最大好處是享受物件導向設計的低耦合與觀注點分離，大大提高程式碼可重用性及可維護性。原生 HTML 自訂元素之前曾玩過一回，做了<a href="/blog/js-rolling-dice/">會滾動的骰子</a>，這回遇到另一個小需求，我想寫過自帶 X 鈕可清空內容的文字輸入框。</p> <p>要做個帶 X 鈕的文字輸入框不難，一個 <code>&lt;input type="text"&gt;</code> 配上用 CSS 排版及自動隱藏的 <code>&lt;button&gt;</code> 就可以搞定，但我有個額外需求是想支援 Vue.js 的 v-model 繫結，讓它可以當成一般的 <code>&lt;input type="text"&gt;</code> 使用。</p> <p>先展示成果：</p> <pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
&lt;meta charset="UTF-8"&gt;
&lt;title&gt;自帶清除鈕文字欄位 Web Component (支援 Vue v-model)&lt;/title&gt;
&lt;script src="https://unpkg.com/vue@3/dist/vue.global.js"&gt;&lt;/script&gt;
&lt;script src="textInputWithClearBtn.js"&gt;&lt;/script&gt;
&lt;style&gt;
body {
font-family: Arial, sans-serif;
margin: 20px;
}
h2 {
color: #444;
}
input-with-clear-button {
margin-bottom: 10px;
display: block;
}
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h2&gt;自帶清除鈕文字欄位&lt;/h2&gt;
&lt;input-with-clear-button id="t1" placeholder="Type something..."&gt;&lt;/input-with-clear-button&gt;
&lt;input-with-clear-button id="t2" value="Hello World"&gt;&lt;/input-with-clear-button&gt;
&lt;button onclick="showValues()"&gt;Check Values&lt;/button&gt;
&lt;pre id="results"&gt;
&lt;/pre&gt;
&lt;script&gt;
function showValues() {
document.getElementById('results').textContent =
`t1: "${document.getElementById('t1').value}"
t2: "${document.getElementById('t2').value}"`;
}
&lt;/script&gt;
&lt;hr&gt;
&lt;div id="app"&gt;
&lt;h2&gt;配合 Vue3 v-model 使用&lt;/h2&gt;
&lt;input-with-clear-button v-model="searchText" placeholder="Search..."&gt;&lt;/input-with-clear-button&gt;
&lt;p&gt;Vue Data Value: {{ searchText }}&lt;/p&gt;
&lt;button @click="searchText = 'Hello Vue3'"&gt;Set Value&lt;/button&gt;
&lt;button @click="searchText = ''"&gt;Clear&lt;/button&gt;
&lt;/div&gt;
&lt;script&gt;
const { createApp } = Vue;
createApp({
data() {
return {
searchText: 'Init Value'
}
}
}).mount('#app');
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre> <p>以上網頁展示單獨使用 <code>&lt;input-with-clear-button&gt;</code>，使用 <code>document.getElementById('t1').value</code> 取值，以及 <code>&lt;input-with-clear-button v-model="searchText" placeholder="Search..."&gt;</code> 以 v-model 整合 Vue.js MVVM，兩種玩法都支援：</p> <p><img src="https://blog.darkthread.net/Posts/files/2025/Fig1_638956780844114351.gif"></p> <p><code>&lt;input-with-clear-button&gt;</code> 定義我寫在獨立 textInputWithClearBtn.js，補充幾個小細節：</p> <ul><li>用 <a href="https://developer.mozilla.org/zh-TW/docs/Glossary/IIFE">IIFE</a> 把定義元件的邏輯包起來，可避免其變數名稱跟其他程式打架。</li> <li>最早我想到的做法是在 HTML 模版內嵌 <code>&lt;style&gt;</code>指定樣式，缺點是每次產生元件 HTML 會重複一次樣式宣告，累贅又沒效率。改用 new CSSStyleSheet()、.replaceSync() 定義 CSS 樣式，HTML 元件透過 adoptedStyleSheets() 共用樣式，優雅多了。</li> <li>observedAttributes() 配合 attributeChangedCallback(name, oldValue, newValue) 可在 Attribute 異動時觸發處理邏輯。</li> <li>實測實作 get value() / set value() 後，<code>&lt;input type="text"&gt;</code> 的按鍵動作便會觸發 Vue v-model 繫結，但按清除鈕 input.value = '' 時需另外呼叫 <code>this.dispatchEvent(new Event('input', { bubbles: true }));</code> 模擬 input 事件。</li></ul> <pre><code>(function() {
// 建立共用的 CSSStyleSheet
const sharedStyles = new CSSStyleSheet();
sharedStyles.replaceSync(`
.text-input-w-clr-btn {
position: relative;
display: inline-block;
margin: 10px 0;
input {
padding: 8px 30px 8px 10px;
font-size: 14px;
border: 1px solid #ccc;
border-radius: 4px;
outline: none;
min-width: 250px;
&amp;:focus { border-color: #4CAF50; }
&amp;:not(:placeholder-shown)~.clear-btn {
display: block;
}
}
.clear-btn {
position: absolute;
right: 8px;
top: 50%;
transform: translateY(-50%);
background: none;
border: none;
cursor: pointer;
color: #999;
font-size: 18px;
padding: 0;
width: 20px;
height: 20px;
line-height: 20px;
text-align: center;
display: none;
&amp;:hover { color: #333;}
}
}
`);
class CustomInput extends HTMLElement {
// 宣告要監聽的屬性
static get observedAttributes() {
return ['value'];
}
constructor() {
super();
this.attachShadow({ mode: 'open' });
this.shadowRoot.adoptedStyleSheets = [sharedStyles];
}
// 元素插入 DOM 時觸發
connectedCallback() {
// 取得 placeholder 屬性值，若無則使用預設值
const placeholder = this.getAttribute('placeholder') || 'Enter text...';
const initialValue = this.getAttribute('value') || '';
// 產生元件 HTML
this.shadowRoot.innerHTML = `
&lt;div class="text-input-w-clr-btn"&gt;
&lt;input type="text" placeholder="${placeholder}" value="${initialValue}"&gt;
&lt;button class="clear-btn" type="button"&gt;×&lt;/button&gt;
&lt;/div&gt;
`;
const input = this.shadowRoot.querySelector('input');
const clearBtn = this.shadowRoot.querySelector('.clear-btn');
clearBtn.addEventListener('click', () =&gt; {
input.value = '';
input.focus();
this.dispatchEvent(new Event('input', { bubbles: true }));
});
}
// 元素從 DOM 移除時觸發
disconnectedCallback() {
}
// 當屬性變更時同步更新 input 值
attributeChangedCallback(name, oldValue, newValue) {
if (name === 'value' &amp;&amp; this.shadowRoot) {
const input = this.shadowRoot.querySelector('input');
if (input &amp;&amp; input.value !== newValue) {
input.value = newValue || '';
}
}
}
// 提供 value 的 getter/setter 供 Vue3 使用
get value() {
return this.shadowRoot?.querySelector('input')?.value || '';
}
set value(val) {
const input = this.shadowRoot?.querySelector('input');
input &amp;&amp; (input.value = val || '');
}
}
customElements.define('input-with-clear-button', CustomInput);
})();
</code></pre> <p>附上<a href="https://darkthread.github.io/comp-terms/web-com-demo.html">線上展示</a></p> <p>註：用原生自訂 HTML 元素跟 Vue 整合，訴求是彈性，可單獨使用不一定綁死 Vue；但若開發環境確定有 Vue 且元件行為跟 Vue 緊密融合，則建議用 Vue 寫自訂元件比較省力。</p> <p data-slug="cust-html-input-element-w-v-model" data-title-en="Native custom HTML input element supporting Vue v-model" data-catg="Web Development" data-fbimg="https://cdn.pixabay.com/photo/2017/09/27/20/34/potter-2793345_960_720.jpg#1280#851">Showcases a native custom HTML input element with a clear (X) button, supporting both standalone use and Vue v-model binding for better reusability and maintainability.</p>]]>
    </itunes:summary>
    <description>
      <![CDATA[<p>自從 IE 登出，Trident 版 Edge 被放生，瀏覽器重回大一統時代。有別於前次的 IE 王朝，當今主宰前端的 Chromium 配備的 HTML / JavaScript / CSS 規格完備，功能與二十年前不可同日而語，且會自動更新不用太擔心支援問題，現在寫前端輕鬆許多。</p> <p>2016 加入的<a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_components/Using_custom_elements">自訂 HTML 元素</a>功能深得我心，自訂元素這檔事幾乎所有前端框架都有自己的玩法，我玩過 <a href="/blog/ko-component/">knockout.js</a>、<a href="/blog/angular-notes-23/">AngularJS</a>、<a href="https://vuejs.org/guide/essentials/component-basics">Vue.js</a>，每個都有，甚至早在 IE6 時代，微軟也有自家的網頁元件技術 - .htc <a href="https://learn.microsoft.com/en-us/openspecs/ie_standards/ms-html401e/36bd9386-cd5f-4bfe-8dec-5efc865a689c?WT.mc_id=DOP-MVP-37580">HTML Component</a>。自訂網頁元件，易於設計維護擴充重用，就像在前端 UI 實踐物件導向設計，好處很多。如今瀏覽器原生支援自訂網頁元素，不需依賴任何框架，效能更佳，運用起來更靈活。</p> <p>UI 元素行為封裝成自訂 HTML 元素，最大好處是享受物件導向設計的低耦合與觀注點分離，大大提高程式碼可重用性及可維護性。原生 HTML 自訂元素之前曾玩過一回，做了<a href="/blog/js-rolling-dice/">會滾動的骰子</a>，這回遇到另一個小需求，我想寫過自帶 X 鈕可清空內容的文字輸入框。</p> <p>要做個帶 X 鈕的文字輸入框不難，一個 <code>&lt;input type="text"&gt;</code> 配上用 CSS 排版及自動隱藏的 <code>&lt;button&gt;</code> 就可以搞定，但我有個額外需求是想支援 Vue.js 的 v-model 繫結，讓它可以當成一般的 <code>&lt;input type="text"&gt;</code> 使用。</p> <p>先展示成果：</p> <pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
&lt;meta charset="UTF-8"&gt;
&lt;title&gt;自帶清除鈕文字欄位 Web Component (支援 Vue v-model)&lt;/title&gt;
&lt;script src="https://unpkg.com/vue@3/dist/vue.global.js"&gt;&lt;/script&gt;
&lt;script src="textInputWithClearBtn.js"&gt;&lt;/script&gt;
&lt;style&gt;
body {
font-family: Arial, sans-serif;
margin: 20px;
}
h2 {
color: #444;
}
input-with-clear-button {
margin-bottom: 10px;
display: block;
}
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h2&gt;自帶清除鈕文字欄位&lt;/h2&gt;
&lt;input-with-clear-button id="t1" placeholder="Type something..."&gt;&lt;/input-with-clear-button&gt;
&lt;input-with-clear-button id="t2" value="Hello World"&gt;&lt;/input-with-clear-button&gt;
&lt;button onclick="showValues()"&gt;Check Values&lt;/button&gt;
&lt;pre id="results"&gt;
&lt;/pre&gt;
&lt;script&gt;
function showValues() {
document.getElementById('results').textContent =
`t1: "${document.getElementById('t1').value}"
t2: "${document.getElementById('t2').value}"`;
}
&lt;/script&gt;
&lt;hr&gt;
&lt;div id="app"&gt;
&lt;h2&gt;配合 Vue3 v-model 使用&lt;/h2&gt;
&lt;input-with-clear-button v-model="searchText" placeholder="Search..."&gt;&lt;/input-with-clear-button&gt;
&lt;p&gt;Vue Data Value: {{ searchText }}&lt;/p&gt;
&lt;button @click="searchText = 'Hello Vue3'"&gt;Set Value&lt;/button&gt;
&lt;button @click="searchText = ''"&gt;Clear&lt;/button&gt;
&lt;/div&gt;
&lt;script&gt;
const { createApp } = Vue;
createApp({
data() {
return {
searchText: 'Init Value'
}
}
}).mount('#app');
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre> <p>以上網頁展示單獨使用 <code>&lt;input-with-clear-button&gt;</code>，使用 <code>document.getElementById('t1').value</code> 取值，以及 <code>&lt;input-with-clear-button v-model="searchText" placeholder="Search..."&gt;</code> 以 v-model 整合 Vue.js MVVM，兩種玩法都支援：</p> <p><img src="https://blog.darkthread.net/Posts/files/2025/Fig1_638956780844114351.gif"></p> <p><code>&lt;input-with-clear-button&gt;</code> 定義我寫在獨立 textInputWithClearBtn.js，補充幾個小細節：</p> <ul><li>用 <a href="https://developer.mozilla.org/zh-TW/docs/Glossary/IIFE">IIFE</a> 把定義元件的邏輯包起來，可避免其變數名稱跟其他程式打架。</li> <li>最早我想到的做法是在 HTML 模版內嵌 <code>&lt;style&gt;</code>指定樣式，缺點是每次產生元件 HTML 會重複一次樣式宣告，累贅又沒效率。改用 new CSSStyleSheet()、.replaceSync() 定義 CSS 樣式，HTML 元件透過 adoptedStyleSheets() 共用樣式，優雅多了。</li> <li>observedAttributes() 配合 attributeChangedCallback(name, oldValue, newValue) 可在 Attribute 異動時觸發處理邏輯。</li> <li>實測實作 get value() / set value() 後，<code>&lt;input type="text"&gt;</code> 的按鍵動作便會觸發 Vue v-model 繫結，但按清除鈕 input.value = '' 時需另外呼叫 <code>this.dispatchEvent(new Event('input', { bubbles: true }));</code> 模擬 input 事件。</li></ul> <pre><code>(function() {
// 建立共用的 CSSStyleSheet
const sharedStyles = new CSSStyleSheet();
sharedStyles.replaceSync(`
.text-input-w-clr-btn {
position: relative;
display: inline-block;
margin: 10px 0;
input {
padding: 8px 30px 8px 10px;
font-size: 14px;
border: 1px solid #ccc;
border-radius: 4px;
outline: none;
min-width: 250px;
&amp;:focus { border-color: #4CAF50; }
&amp;:not(:placeholder-shown)~.clear-btn {
display: block;
}
}
.clear-btn {
position: absolute;
right: 8px;
top: 50%;
transform: translateY(-50%);
background: none;
border: none;
cursor: pointer;
color: #999;
font-size: 18px;
padding: 0;
width: 20px;
height: 20px;
line-height: 20px;
text-align: center;
display: none;
&amp;:hover { color: #333;}
}
}
`);
class CustomInput extends HTMLElement {
// 宣告要監聽的屬性
static get observedAttributes() {
return ['value'];
}
constructor() {
super();
this.attachShadow({ mode: 'open' });
this.shadowRoot.adoptedStyleSheets = [sharedStyles];
}
// 元素插入 DOM 時觸發
connectedCallback() {
// 取得 placeholder 屬性值，若無則使用預設值
const placeholder = this.getAttribute('placeholder') || 'Enter text...';
const initialValue = this.getAttribute('value') || '';
// 產生元件 HTML
this.shadowRoot.innerHTML = `
&lt;div class="text-input-w-clr-btn"&gt;
&lt;input type="text" placeholder="${placeholder}" value="${initialValue}"&gt;
&lt;button class="clear-btn" type="button"&gt;×&lt;/button&gt;
&lt;/div&gt;
`;
const input = this.shadowRoot.querySelector('input');
const clearBtn = this.shadowRoot.querySelector('.clear-btn');
clearBtn.addEventListener('click', () =&gt; {
input.value = '';
input.focus();
this.dispatchEvent(new Event('input', { bubbles: true }));
});
}
// 元素從 DOM 移除時觸發
disconnectedCallback() {
}
// 當屬性變更時同步更新 input 值
attributeChangedCallback(name, oldValue, newValue) {
if (name === 'value' &amp;&amp; this.shadowRoot) {
const input = this.shadowRoot.querySelector('input');
if (input &amp;&amp; input.value !== newValue) {
input.value = newValue || '';
}
}
}
// 提供 value 的 getter/setter 供 Vue3 使用
get value() {
return this.shadowRoot?.querySelector('input')?.value || '';
}
set value(val) {
const input = this.shadowRoot?.querySelector('input');
input &amp;&amp; (input.value = val || '');
}
}
customElements.define('input-with-clear-button', CustomInput);
})();
</code></pre> <p>附上<a href="https://darkthread.github.io/comp-terms/web-com-demo.html">線上展示</a></p> <p>註：用原生自訂 HTML 元素跟 Vue 整合，訴求是彈性，可單獨使用不一定綁死 Vue；但若開發環境確定有 Vue 且元件行為跟 Vue 緊密融合，則建議用 Vue 寫自訂元件比較省力。</p> <p data-slug="cust-html-input-element-w-v-model" data-title-en="Native custom HTML input element supporting Vue v-model" data-catg="Web Development" data-fbimg="https://cdn.pixabay.com/photo/2017/09/27/20/34/potter-2793345_960_720.jpg#1280#851">Showcases a native custom HTML input element with a clear (X) button, supporting both standalone use and Vue v-model binding for better reusability and maintainability.</p>]]>
    </description>
    <content:encoded><![CDATA[<p>自從 IE 登出，Trident 版 Edge 被放生，瀏覽器重回大一統時代。有別於前次的 IE 王朝，當今主宰前端的 Chromium 配備的 HTML / JavaScript / CSS 規格完備，功能與二十年前不可同日而語，且會自動更新不用太擔心支援問題，現在寫前端輕鬆許多。</p> <p>2016 加入的<a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_components/Using_custom_elements">自訂 HTML 元素</a>功能深得我心，自訂元素這檔事幾乎所有前端框架都有自己的玩法，我玩過 <a href="/blog/ko-component/">knockout.js</a>、<a href="/blog/angular-notes-23/">AngularJS</a>、<a href="https://vuejs.org/guide/essentials/component-basics">Vue.js</a>，每個都有，甚至早在 IE6 時代，微軟也有自家的網頁元件技術 - .htc <a href="https://learn.microsoft.com/en-us/openspecs/ie_standards/ms-html401e/36bd9386-cd5f-4bfe-8dec-5efc865a689c?WT.mc_id=DOP-MVP-37580">HTML Component</a>。自訂網頁元件，易於設計維護擴充重用，就像在前端 UI 實踐物件導向設計，好處很多。如今瀏覽器原生支援自訂網頁元素，不需依賴任何框架，效能更佳，運用起來更靈活。</p> <p>UI 元素行為封裝成自訂 HTML 元素，最大好處是享受物件導向設計的低耦合與觀注點分離，大大提高程式碼可重用性及可維護性。原生 HTML 自訂元素之前曾玩過一回，做了<a href="/blog/js-rolling-dice/">會滾動的骰子</a>，這回遇到另一個小需求，我想寫過自帶 X 鈕可清空內容的文字輸入框。</p> <p>要做個帶 X 鈕的文字輸入框不難，一個 <code>&lt;input type="text"&gt;</code> 配上用 CSS 排版及自動隱藏的 <code>&lt;button&gt;</code> 就可以搞定，但我有個額外需求是想支援 Vue.js 的 v-model 繫結，讓它可以當成一般的 <code>&lt;input type="text"&gt;</code> 使用。</p> <p>先展示成果：</p> <pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
&lt;meta charset="UTF-8"&gt;
&lt;title&gt;自帶清除鈕文字欄位 Web Component (支援 Vue v-model)&lt;/title&gt;
&lt;script src="https://unpkg.com/vue@3/dist/vue.global.js"&gt;&lt;/script&gt;
&lt;script src="textInputWithClearBtn.js"&gt;&lt;/script&gt;
&lt;style&gt;
body {
font-family: Arial, sans-serif;
margin: 20px;
}
h2 {
color: #444;
}
input-with-clear-button {
margin-bottom: 10px;
display: block;
}
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h2&gt;自帶清除鈕文字欄位&lt;/h2&gt;
&lt;input-with-clear-button id="t1" placeholder="Type something..."&gt;&lt;/input-with-clear-button&gt;
&lt;input-with-clear-button id="t2" value="Hello World"&gt;&lt;/input-with-clear-button&gt;
&lt;button onclick="showValues()"&gt;Check Values&lt;/button&gt;
&lt;pre id="results"&gt;
&lt;/pre&gt;
&lt;script&gt;
function showValues() {
document.getElementById('results').textContent =
`t1: "${document.getElementById('t1').value}"
t2: "${document.getElementById('t2').value}"`;
}
&lt;/script&gt;
&lt;hr&gt;
&lt;div id="app"&gt;
&lt;h2&gt;配合 Vue3 v-model 使用&lt;/h2&gt;
&lt;input-with-clear-button v-model="searchText" placeholder="Search..."&gt;&lt;/input-with-clear-button&gt;
&lt;p&gt;Vue Data Value: {{ searchText }}&lt;/p&gt;
&lt;button @click="searchText = 'Hello Vue3'"&gt;Set Value&lt;/button&gt;
&lt;button @click="searchText = ''"&gt;Clear&lt;/button&gt;
&lt;/div&gt;
&lt;script&gt;
const { createApp } = Vue;
createApp({
data() {
return {
searchText: 'Init Value'
}
}
}).mount('#app');
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre> <p>以上網頁展示單獨使用 <code>&lt;input-with-clear-button&gt;</code>，使用 <code>document.getElementById('t1').value</code> 取值，以及 <code>&lt;input-with-clear-button v-model="searchText" placeholder="Search..."&gt;</code> 以 v-model 整合 Vue.js MVVM，兩種玩法都支援：</p> <p><img src="https://blog.darkthread.net/Posts/files/2025/Fig1_638956780844114351.gif"></p> <p><code>&lt;input-with-clear-button&gt;</code> 定義我寫在獨立 textInputWithClearBtn.js，補充幾個小細節：</p> <ul><li>用 <a href="https://developer.mozilla.org/zh-TW/docs/Glossary/IIFE">IIFE</a> 把定義元件的邏輯包起來，可避免其變數名稱跟其他程式打架。</li> <li>最早我想到的做法是在 HTML 模版內嵌 <code>&lt;style&gt;</code>指定樣式，缺點是每次產生元件 HTML 會重複一次樣式宣告，累贅又沒效率。改用 new CSSStyleSheet()、.replaceSync() 定義 CSS 樣式，HTML 元件透過 adoptedStyleSheets() 共用樣式，優雅多了。</li> <li>observedAttributes() 配合 attributeChangedCallback(name, oldValue, newValue) 可在 Attribute 異動時觸發處理邏輯。</li> <li>實測實作 get value() / set value() 後，<code>&lt;input type="text"&gt;</code> 的按鍵動作便會觸發 Vue v-model 繫結，但按清除鈕 input.value = '' 時需另外呼叫 <code>this.dispatchEvent(new Event('input', { bubbles: true }));</code> 模擬 input 事件。</li></ul> <pre><code>(function() {
// 建立共用的 CSSStyleSheet
const sharedStyles = new CSSStyleSheet();
sharedStyles.replaceSync(`
.text-input-w-clr-btn {
position: relative;
display: inline-block;
margin: 10px 0;
input {
padding: 8px 30px 8px 10px;
font-size: 14px;
border: 1px solid #ccc;
border-radius: 4px;
outline: none;
min-width: 250px;
&amp;:focus { border-color: #4CAF50; }
&amp;:not(:placeholder-shown)~.clear-btn {
display: block;
}
}
.clear-btn {
position: absolute;
right: 8px;
top: 50%;
transform: translateY(-50%);
background: none;
border: none;
cursor: pointer;
color: #999;
font-size: 18px;
padding: 0;
width: 20px;
height: 20px;
line-height: 20px;
text-align: center;
display: none;
&amp;:hover { color: #333;}
}
}
`);
class CustomInput extends HTMLElement {
// 宣告要監聽的屬性
static get observedAttributes() {
return ['value'];
}
constructor() {
super();
this.attachShadow({ mode: 'open' });
this.shadowRoot.adoptedStyleSheets = [sharedStyles];
}
// 元素插入 DOM 時觸發
connectedCallback() {
// 取得 placeholder 屬性值，若無則使用預設值
const placeholder = this.getAttribute('placeholder') || 'Enter text...';
const initialValue = this.getAttribute('value') || '';
// 產生元件 HTML
this.shadowRoot.innerHTML = `
&lt;div class="text-input-w-clr-btn"&gt;
&lt;input type="text" placeholder="${placeholder}" value="${initialValue}"&gt;
&lt;button class="clear-btn" type="button"&gt;×&lt;/button&gt;
&lt;/div&gt;
`;
const input = this.shadowRoot.querySelector('input');
const clearBtn = this.shadowRoot.querySelector('.clear-btn');
clearBtn.addEventListener('click', () =&gt; {
input.value = '';
input.focus();
this.dispatchEvent(new Event('input', { bubbles: true }));
});
}
// 元素從 DOM 移除時觸發
disconnectedCallback() {
}
// 當屬性變更時同步更新 input 值
attributeChangedCallback(name, oldValue, newValue) {
if (name === 'value' &amp;&amp; this.shadowRoot) {
const input = this.shadowRoot.querySelector('input');
if (input &amp;&amp; input.value !== newValue) {
input.value = newValue || '';
}
}
}
// 提供 value 的 getter/setter 供 Vue3 使用
get value() {
return this.shadowRoot?.querySelector('input')?.value || '';
}
set value(val) {
const input = this.shadowRoot?.querySelector('input');
input &amp;&amp; (input.value = val || '');
}
}
customElements.define('input-with-clear-button', CustomInput);
})();
</code></pre> <p>附上<a href="https://darkthread.github.io/comp-terms/web-com-demo.html">線上展示</a></p> <p>註：用原生自訂 HTML 元素跟 Vue 整合，訴求是彈性，可單獨使用不一定綁死 Vue；但若開發環境確定有 Vue 且元件行為跟 Vue 緊密融合，則建議用 Vue 寫自訂元件比較省力。</p> <p data-slug="cust-html-input-element-w-v-model" data-title-en="Native custom HTML input element supporting Vue v-model" data-catg="Web Development" data-fbimg="https://cdn.pixabay.com/photo/2017/09/27/20/34/potter-2793345_960_720.jpg#1280#851">Showcases a native custom HTML input element with a clear (X) button, supporting both standalone use and Vue v-model binding for better reusability and maintainability.</p>]]></content:encoded>
    <itunes:image href="https://blog.darkthread.net/Posts/files/2025/Fig1_638956780844114351.gif"/>
          <media:content url="https://blog.darkthread.net/Posts/files/2025/Fig1_638956780844114351.gif" medium="image"/>
    <pubDate>Fri, 10 Oct 2025 07:21:07 GMT</pubDate>
  </item><item>
    <title><![CDATA[Debian 設定自動校時 (原來 Github Copilot 連這也會)]]></title>
    <link>https://blog.darkthread.net/blog/set-timesyncd-for-debian12/</link>
    <itunes:title><![CDATA[Debian 設定自動校時 (原來 Github Copilot 連這也會)]]></itunes:title>
    <itunes:author><![CDATA[service@darkthread.net (Jeffrey Lee)]]></itunes:author>
    <itunes:summary>
      <![CDATA[<p>家用迷你伺服器自從<a href="/blog/centos7-debian12-migrate/">升級 Debian 12</a>後又變得好玩起來，不再因 OS 版本太舊這個不能裝那個不能用，我又開始玩一堆有的沒的。</p> <p>上回學會<a href="/blog/homebrew-siem-for-openvpn-connection-alert/">用 bash 發資安事件通知給 Slack </a>，這回我弄了一個定期狀態檢查，用 cron 每小時傳一次統計到 Slack，但發現一個小問題，排程設每小時的 30 分執行，但實際執行時間卻是 31 分。</p> <p>我是<a href="/blog/vscode-remote-ssh/">用 VSCode 連上 Debian 遠端寫 Code</a>，二話不說直接在 Github Copilot Chat 發問，Copilot 教我可以用 <code>timedatectl status</code> 檢查。查詢結果，Debian 時間果然慢了一分鐘，而且沒設 <a href="/blog/ptp/">NTP</a> ，照著 Copilot 教學用 <code>sudo timedatectl set-ntp true</code> 想設定自動校則會出錯。</p> <pre><code>jeffrey@debian12:~/$ timedatectl status
Local time: 四 2025-10-09 20:26:52 CST
Universal time: 四 2025-10-09 12:26:52 UTC
RTC time: 四 2025-10-09 12:26:53
Time zone: Asia/Taipei (CST, +0800)
System clock synchronized: no
NTP service: n/a
RTC in local TZ: no
jeffrey@debian12:~/$ sudo timedatectl set-ntp true
Failed to set ntp: NTP not supported
</code></pre> <p>有趣的部分來了，這回我沒爬文找教學，一時興起切到 Copilot Agent 模式問 Copilot 為什麼會遇到 <code>Failed to set ntp: NTP not supported</code> 錯誤，Copilot 說應該是因為 systemd-timesyncd 沒有安裝或被停用了，<strong>問我要不要讓它接手檢查並修復</strong>？</p> <p>好啊! 看看 Copilot 有什麼本事也好。</p> <p>Copilot 新開了一個專屬 bash 終端機視窗(下圖箭頭所指)，可以傳指令過去執行並取回執行結果檢查，而每次執行指令前都會徵求我的同意，我的習慣也是每個指令都會看過才放行，一來審查二則學習。</p> <p><img src="https://blog.darkthread.net/Posts/files/2025/Fig2_638956128354912368.png"></p> <p>一套組合拳下來，Copilot 先跑了 <code>systemctl status systemd-timesyncd</code>、<code>dpkg -l | grep -E 'ntp|chrony|timesyncd'</code> 確認主機真的沒有裝任何校時服務，接著 <code>sudo apt update</code>、<code>sudo apt install -y systemd-timesyncd</code>、<code>sudo timedatectl set-ntp true</code> 安裝設定一氣喝成，</p> <p><img src="https://blog.darkthread.net/Posts/files/2025/Fig1_638956128358198355.png"></p> <p>原來不只寫程式，這年頭連系統管理 AI 都能代勞惹!</p> <p>不過，我的原則是「事情 AI 可以搶去做，但知識必須留下」，以下是 Debian 設定自動校時的背景知識整理。</p> <ul><li>Debian 12 安裝後預設未啟用自動校時，需自行設定。</li> <li>systemd 是現代 Linux 發行版廣泛採用的系統與服務管理程序，取代了傳統 SysV init 系統。它負責系統啟動流程、服務啟動停止管理、硬體與登錄檔監控，以及日誌收集等，透過一致化機制簡化系統管理。<br> 常用指令包含 <code>systemctl</code>(服務管理)、<code>journalctl</code>(系統日誌查詢)、<code>timedatectl</code>(時間與時區管理)、<code>hostnamectl</code>(主機名稱與作業系統資訊)。<br> (註：systemd 的歷史不算久，但 2010 年推出後很快席捲各大 Linux 發行版本，成為內建核心組件。難怪這些年沒看過有人再提 /etc/init.d ...)</li> <li><code>timedatectl status</code> 能一次查詢時間與 NTP 同步設定，超方便。<br> <img src="https://blog.darkthread.net/Posts/files/2025/Fig3_638956128359810834.png"></li> <li>systemd-timesyncd 是 systemd 套件提供的輕量級 NTP 客戶端，負責與遠端時間伺服器同步本地系統時鐘。與 ntpd、chrony 等傳統服務相比，它設計簡潔、整合度高，是時間同步方案。</li> <li><code>dpkg -l | grep -E 'ntp|chrony|timesyncd'</code> 這招可以檢查是否有裝任何時間同步服務首選。</li> <li><code>timedatectl set-ntp true</code> 背後會執行 <code>systemctl enable systemd-timesyncd.service</code>、<code>systemctl start systemd-timesyncd.service</code>，啟用 systemd-timesyncd 並設為開機後自動執行。</li></ul> <p data-slug="set-timesyncd-for-debian12" data-fbimg="https://upload.wikimedia.org/wikipedia/commons/thumb/3/3b/Melbourne_sundial_at_Flagstaff_Gardens.JPG/1080px-Melbourne_sundial_at_Flagstaff_Gardens.JPG#1080#720"> </p>]]>
    </itunes:summary>
    <description>
      <![CDATA[<p>家用迷你伺服器自從<a href="/blog/centos7-debian12-migrate/">升級 Debian 12</a>後又變得好玩起來，不再因 OS 版本太舊這個不能裝那個不能用，我又開始玩一堆有的沒的。</p> <p>上回學會<a href="/blog/homebrew-siem-for-openvpn-connection-alert/">用 bash 發資安事件通知給 Slack </a>，這回我弄了一個定期狀態檢查，用 cron 每小時傳一次統計到 Slack，但發現一個小問題，排程設每小時的 30 分執行，但實際執行時間卻是 31 分。</p> <p>我是<a href="/blog/vscode-remote-ssh/">用 VSCode 連上 Debian 遠端寫 Code</a>，二話不說直接在 Github Copilot Chat 發問，Copilot 教我可以用 <code>timedatectl status</code> 檢查。查詢結果，Debian 時間果然慢了一分鐘，而且沒設 <a href="/blog/ptp/">NTP</a> ，照著 Copilot 教學用 <code>sudo timedatectl set-ntp true</code> 想設定自動校則會出錯。</p> <pre><code>jeffrey@debian12:~/$ timedatectl status
Local time: 四 2025-10-09 20:26:52 CST
Universal time: 四 2025-10-09 12:26:52 UTC
RTC time: 四 2025-10-09 12:26:53
Time zone: Asia/Taipei (CST, +0800)
System clock synchronized: no
NTP service: n/a
RTC in local TZ: no
jeffrey@debian12:~/$ sudo timedatectl set-ntp true
Failed to set ntp: NTP not supported
</code></pre> <p>有趣的部分來了，這回我沒爬文找教學，一時興起切到 Copilot Agent 模式問 Copilot 為什麼會遇到 <code>Failed to set ntp: NTP not supported</code> 錯誤，Copilot 說應該是因為 systemd-timesyncd 沒有安裝或被停用了，<strong>問我要不要讓它接手檢查並修復</strong>？</p> <p>好啊! 看看 Copilot 有什麼本事也好。</p> <p>Copilot 新開了一個專屬 bash 終端機視窗(下圖箭頭所指)，可以傳指令過去執行並取回執行結果檢查，而每次執行指令前都會徵求我的同意，我的習慣也是每個指令都會看過才放行，一來審查二則學習。</p> <p><img src="https://blog.darkthread.net/Posts/files/2025/Fig2_638956128354912368.png"></p> <p>一套組合拳下來，Copilot 先跑了 <code>systemctl status systemd-timesyncd</code>、<code>dpkg -l | grep -E 'ntp|chrony|timesyncd'</code> 確認主機真的沒有裝任何校時服務，接著 <code>sudo apt update</code>、<code>sudo apt install -y systemd-timesyncd</code>、<code>sudo timedatectl set-ntp true</code> 安裝設定一氣喝成，</p> <p><img src="https://blog.darkthread.net/Posts/files/2025/Fig1_638956128358198355.png"></p> <p>原來不只寫程式，這年頭連系統管理 AI 都能代勞惹!</p> <p>不過，我的原則是「事情 AI 可以搶去做，但知識必須留下」，以下是 Debian 設定自動校時的背景知識整理。</p> <ul><li>Debian 12 安裝後預設未啟用自動校時，需自行設定。</li> <li>systemd 是現代 Linux 發行版廣泛採用的系統與服務管理程序，取代了傳統 SysV init 系統。它負責系統啟動流程、服務啟動停止管理、硬體與登錄檔監控，以及日誌收集等，透過一致化機制簡化系統管理。<br> 常用指令包含 <code>systemctl</code>(服務管理)、<code>journalctl</code>(系統日誌查詢)、<code>timedatectl</code>(時間與時區管理)、<code>hostnamectl</code>(主機名稱與作業系統資訊)。<br> (註：systemd 的歷史不算久，但 2010 年推出後很快席捲各大 Linux 發行版本，成為內建核心組件。難怪這些年沒看過有人再提 /etc/init.d ...)</li> <li><code>timedatectl status</code> 能一次查詢時間與 NTP 同步設定，超方便。<br> <img src="https://blog.darkthread.net/Posts/files/2025/Fig3_638956128359810834.png"></li> <li>systemd-timesyncd 是 systemd 套件提供的輕量級 NTP 客戶端，負責與遠端時間伺服器同步本地系統時鐘。與 ntpd、chrony 等傳統服務相比，它設計簡潔、整合度高，是時間同步方案。</li> <li><code>dpkg -l | grep -E 'ntp|chrony|timesyncd'</code> 這招可以檢查是否有裝任何時間同步服務首選。</li> <li><code>timedatectl set-ntp true</code> 背後會執行 <code>systemctl enable systemd-timesyncd.service</code>、<code>systemctl start systemd-timesyncd.service</code>，啟用 systemd-timesyncd 並設為開機後自動執行。</li></ul> <p data-slug="set-timesyncd-for-debian12" data-fbimg="https://upload.wikimedia.org/wikipedia/commons/thumb/3/3b/Melbourne_sundial_at_Flagstaff_Gardens.JPG/1080px-Melbourne_sundial_at_Flagstaff_Gardens.JPG#1080#720"> </p>]]>
    </description>
    <content:encoded><![CDATA[<p>家用迷你伺服器自從<a href="/blog/centos7-debian12-migrate/">升級 Debian 12</a>後又變得好玩起來，不再因 OS 版本太舊這個不能裝那個不能用，我又開始玩一堆有的沒的。</p> <p>上回學會<a href="/blog/homebrew-siem-for-openvpn-connection-alert/">用 bash 發資安事件通知給 Slack </a>，這回我弄了一個定期狀態檢查，用 cron 每小時傳一次統計到 Slack，但發現一個小問題，排程設每小時的 30 分執行，但實際執行時間卻是 31 分。</p> <p>我是<a href="/blog/vscode-remote-ssh/">用 VSCode 連上 Debian 遠端寫 Code</a>，二話不說直接在 Github Copilot Chat 發問，Copilot 教我可以用 <code>timedatectl status</code> 檢查。查詢結果，Debian 時間果然慢了一分鐘，而且沒設 <a href="/blog/ptp/">NTP</a> ，照著 Copilot 教學用 <code>sudo timedatectl set-ntp true</code> 想設定自動校則會出錯。</p> <pre><code>jeffrey@debian12:~/$ timedatectl status
Local time: 四 2025-10-09 20:26:52 CST
Universal time: 四 2025-10-09 12:26:52 UTC
RTC time: 四 2025-10-09 12:26:53
Time zone: Asia/Taipei (CST, +0800)
System clock synchronized: no
NTP service: n/a
RTC in local TZ: no
jeffrey@debian12:~/$ sudo timedatectl set-ntp true
Failed to set ntp: NTP not supported
</code></pre> <p>有趣的部分來了，這回我沒爬文找教學，一時興起切到 Copilot Agent 模式問 Copilot 為什麼會遇到 <code>Failed to set ntp: NTP not supported</code> 錯誤，Copilot 說應該是因為 systemd-timesyncd 沒有安裝或被停用了，<strong>問我要不要讓它接手檢查並修復</strong>？</p> <p>好啊! 看看 Copilot 有什麼本事也好。</p> <p>Copilot 新開了一個專屬 bash 終端機視窗(下圖箭頭所指)，可以傳指令過去執行並取回執行結果檢查，而每次執行指令前都會徵求我的同意，我的習慣也是每個指令都會看過才放行，一來審查二則學習。</p> <p><img src="https://blog.darkthread.net/Posts/files/2025/Fig2_638956128354912368.png"></p> <p>一套組合拳下來，Copilot 先跑了 <code>systemctl status systemd-timesyncd</code>、<code>dpkg -l | grep -E 'ntp|chrony|timesyncd'</code> 確認主機真的沒有裝任何校時服務，接著 <code>sudo apt update</code>、<code>sudo apt install -y systemd-timesyncd</code>、<code>sudo timedatectl set-ntp true</code> 安裝設定一氣喝成，</p> <p><img src="https://blog.darkthread.net/Posts/files/2025/Fig1_638956128358198355.png"></p> <p>原來不只寫程式，這年頭連系統管理 AI 都能代勞惹!</p> <p>不過，我的原則是「事情 AI 可以搶去做，但知識必須留下」，以下是 Debian 設定自動校時的背景知識整理。</p> <ul><li>Debian 12 安裝後預設未啟用自動校時，需自行設定。</li> <li>systemd 是現代 Linux 發行版廣泛採用的系統與服務管理程序，取代了傳統 SysV init 系統。它負責系統啟動流程、服務啟動停止管理、硬體與登錄檔監控，以及日誌收集等，透過一致化機制簡化系統管理。<br> 常用指令包含 <code>systemctl</code>(服務管理)、<code>journalctl</code>(系統日誌查詢)、<code>timedatectl</code>(時間與時區管理)、<code>hostnamectl</code>(主機名稱與作業系統資訊)。<br> (註：systemd 的歷史不算久，但 2010 年推出後很快席捲各大 Linux 發行版本，成為內建核心組件。難怪這些年沒看過有人再提 /etc/init.d ...)</li> <li><code>timedatectl status</code> 能一次查詢時間與 NTP 同步設定，超方便。<br> <img src="https://blog.darkthread.net/Posts/files/2025/Fig3_638956128359810834.png"></li> <li>systemd-timesyncd 是 systemd 套件提供的輕量級 NTP 客戶端，負責與遠端時間伺服器同步本地系統時鐘。與 ntpd、chrony 等傳統服務相比，它設計簡潔、整合度高，是時間同步方案。</li> <li><code>dpkg -l | grep -E 'ntp|chrony|timesyncd'</code> 這招可以檢查是否有裝任何時間同步服務首選。</li> <li><code>timedatectl set-ntp true</code> 背後會執行 <code>systemctl enable systemd-timesyncd.service</code>、<code>systemctl start systemd-timesyncd.service</code>，啟用 systemd-timesyncd 並設為開機後自動執行。</li></ul> <p data-slug="set-timesyncd-for-debian12" data-fbimg="https://upload.wikimedia.org/wikipedia/commons/thumb/3/3b/Melbourne_sundial_at_Flagstaff_Gardens.JPG/1080px-Melbourne_sundial_at_Flagstaff_Gardens.JPG#1080#720"> </p>]]></content:encoded>
    <itunes:image href="https://blog.darkthread.net/Posts/files/2025/Fig2_638956128354912368.png"/>
          <media:content url="https://blog.darkthread.net/Posts/files/2025/Fig2_638956128354912368.png" medium="image"/>
    <pubDate>Thu, 09 Oct 2025 13:20:14 GMT</pubDate>
  </item><item>
    <title><![CDATA[該選 .NET Framework 4.8 還是 .NET Framework 4.8.1？]]></title>
    <link>https://blog.darkthread.net/blog/netfx-48-or-481/</link>
    <itunes:title><![CDATA[該選 .NET Framework 4.8 還是 .NET Framework 4.8.1？]]></itunes:title>
    <itunes:author><![CDATA[service@darkthread.net (Jeffrey Lee)]]></itunes:author>
    <itunes:summary>
      <![CDATA[<p>安裝 Visual Studio 時，我們可以選擇要安裝哪些版本 .NET Framework ：</p> <p><img src="https://blog.darkthread.net/Posts/files/2025/Fig1_638955276014073226.png"></p> <p>註：SDK 與目標套件差在哪裡？SDK 包含編譯器整合、設計工具、參考組件、專案範本與建置支援，必須要安裝才能在 Visual Studio 建立及編輯該版本的 .NET Framework 應用程式專案(例如 WinForms/WPF)；至於目標套件(Targeting Pack) 僅包含特定 .NET Framework 版本的參考組件與目標檔案，讓專案可以將 Target Framework 設為該版本並成功編譯，不提供設計工具與額外範本。<a href="https://learn.microsoft.com/en-us/dotnet/framework/install/guide-for-developers?WT.mc_id=DOP-MVP-37580#to-install-the-net-framework-developer-pack-or-targeting-pack">參考</a></p> <p>在 .NET Framework 專案設定視窗，我們可以選擇編譯成有安裝目標套件的 .NET Framework 版本。</p> <p><img src="https://blog.darkthread.net/Posts/files/2025/Fig2_638955276015786136.png"></p> <p>補充隱藏觀念：.NET 4.X 採「就地更新」(In-Place Update)政策，.NET 4.X 安裝時會覆寫換掉 \Windows.NET Framework\V4.0.30319 的 .NET 4 舊版 dll，沿用相同目錄同樣檔名但置換成新版本。故安裝 .NET 4.8 後， 以 .NET 4.0、4.5、4.6、4.7、4.8 為目標編譯的程式都是使用 .NET 4.8 版的 Runtime，選取 Target Framework 可讓程式執行時向下相容，模擬舊版本行為。 延伸閱讀：<a href="/blog/ref-higher-netfx-ver-dll/">.NET 4.6 專案可以參照及使用 .NET 4.8 編譯的程式庫嗎？</a>、<a href="/blog/httruntime-targetframework/">認識 web.config compilation 與 httpRuntime 的 targetFramework</a></p> <p>針對 .NET Framework 專案，我們可以選擇編譯成 .NET 4.6.2、.NET 4.7.2、...、.NET 4.8、.NET 4.8.1，依據新版會修掉一些 Bug、版本愈新可以用愈久(愈晚面對 EOS)... 等慣例，所以我們該義無反顧選 .NET 4.8.1？</p> <p>錯!</p> <p>依據 <a href="https://learn.microsoft.com/zh-tw/lifecycle/faq/dotnet-framework?WT.mc_id=DOP-MVP-37580#-----net-framework---------------">官方文件</a>，.NET 4.8 將以 Windows 元件形式提供，其支援週期與 Windows 看齊，也就是 Windows 用多久，.NET 4.8 就能用多久，不須擔心提早 EOS。而微軟也建議客戶升級至 .NET Framework 4.8 以獲得最高層級的效能、可靠性和安全性。(依據 Windows Server 2025 內建 .NET 4.8.1 推算，.NET Framework 4.8 至少能再戰個十年以上吧)</p> <p>微軟在 2019-04-18 推出 .NET 4.8，.NET Framework 發展就封頂了，.NET 路線改較由 .NET 5/6/7/8... 傳承下去。兩年多後 (2022-08-09) 推出的 .NET 4.8.1 只做了很微小的強化，主要是加入對 Arm64 CPU 的支援、強化 Windows Forms/ WPF 的 WCGA2.1 無障礙標準支援，應用程式未必會用到。但 4.8.1 較大的問題是一些舊版作業系統不支援，像是 Windows 7 SP1、Windows 8.1、Windows 10 2004/1909/1903、Windows Server 2019/2016/2012 R2/2012... 等。其中 Windows Server 2016 到 <a href="https://learn.microsoft.com/zh-tw/lifecycle/products/windows-server-2016?WT.mc_id=DOP-MVP-37580">2027-01-12 才 EOS</a>，2019 則是 <a href="https://learn.microsoft.com/zh-tw/lifecycle/products/windows-server-2019?WT.mc_id=DOP-MVP-37580">2029-01-09</a>，因此若程式會部署到 Window Server 2022 之前的伺服器，就必須留意作業系統不支援的問題。</p> <p>評估之後，若沒有 Arm64 及 Windows Form/WPF 無障礙需求，.NET 4.8 應是相容性更高的好選擇，結案。</p> <p data-slug="netfx-48-or-481" data-title-en="Should I choose .NET 4.8.1 or 4.8?" data-catg=".NET" data-fbimg="https://cdn.pixabay.com/photo/2018/04/11/08/59/rails-3309912_1280.jpg#1280#720">Choose .NET Framework 4.8 over 4.8.1 for broader OS compatibility unless Arm64 or accessibility features are required; support aligns with Windows lifecycle.</p>]]>
    </itunes:summary>
    <description>
      <![CDATA[<p>安裝 Visual Studio 時，我們可以選擇要安裝哪些版本 .NET Framework ：</p> <p><img src="https://blog.darkthread.net/Posts/files/2025/Fig1_638955276014073226.png"></p> <p>註：SDK 與目標套件差在哪裡？SDK 包含編譯器整合、設計工具、參考組件、專案範本與建置支援，必須要安裝才能在 Visual Studio 建立及編輯該版本的 .NET Framework 應用程式專案(例如 WinForms/WPF)；至於目標套件(Targeting Pack) 僅包含特定 .NET Framework 版本的參考組件與目標檔案，讓專案可以將 Target Framework 設為該版本並成功編譯，不提供設計工具與額外範本。<a href="https://learn.microsoft.com/en-us/dotnet/framework/install/guide-for-developers?WT.mc_id=DOP-MVP-37580#to-install-the-net-framework-developer-pack-or-targeting-pack">參考</a></p> <p>在 .NET Framework 專案設定視窗，我們可以選擇編譯成有安裝目標套件的 .NET Framework 版本。</p> <p><img src="https://blog.darkthread.net/Posts/files/2025/Fig2_638955276015786136.png"></p> <p>補充隱藏觀念：.NET 4.X 採「就地更新」(In-Place Update)政策，.NET 4.X 安裝時會覆寫換掉 \Windows.NET Framework\V4.0.30319 的 .NET 4 舊版 dll，沿用相同目錄同樣檔名但置換成新版本。故安裝 .NET 4.8 後， 以 .NET 4.0、4.5、4.6、4.7、4.8 為目標編譯的程式都是使用 .NET 4.8 版的 Runtime，選取 Target Framework 可讓程式執行時向下相容，模擬舊版本行為。 延伸閱讀：<a href="/blog/ref-higher-netfx-ver-dll/">.NET 4.6 專案可以參照及使用 .NET 4.8 編譯的程式庫嗎？</a>、<a href="/blog/httruntime-targetframework/">認識 web.config compilation 與 httpRuntime 的 targetFramework</a></p> <p>針對 .NET Framework 專案，我們可以選擇編譯成 .NET 4.6.2、.NET 4.7.2、...、.NET 4.8、.NET 4.8.1，依據新版會修掉一些 Bug、版本愈新可以用愈久(愈晚面對 EOS)... 等慣例，所以我們該義無反顧選 .NET 4.8.1？</p> <p>錯!</p> <p>依據 <a href="https://learn.microsoft.com/zh-tw/lifecycle/faq/dotnet-framework?WT.mc_id=DOP-MVP-37580#-----net-framework---------------">官方文件</a>，.NET 4.8 將以 Windows 元件形式提供，其支援週期與 Windows 看齊，也就是 Windows 用多久，.NET 4.8 就能用多久，不須擔心提早 EOS。而微軟也建議客戶升級至 .NET Framework 4.8 以獲得最高層級的效能、可靠性和安全性。(依據 Windows Server 2025 內建 .NET 4.8.1 推算，.NET Framework 4.8 至少能再戰個十年以上吧)</p> <p>微軟在 2019-04-18 推出 .NET 4.8，.NET Framework 發展就封頂了，.NET 路線改較由 .NET 5/6/7/8... 傳承下去。兩年多後 (2022-08-09) 推出的 .NET 4.8.1 只做了很微小的強化，主要是加入對 Arm64 CPU 的支援、強化 Windows Forms/ WPF 的 WCGA2.1 無障礙標準支援，應用程式未必會用到。但 4.8.1 較大的問題是一些舊版作業系統不支援，像是 Windows 7 SP1、Windows 8.1、Windows 10 2004/1909/1903、Windows Server 2019/2016/2012 R2/2012... 等。其中 Windows Server 2016 到 <a href="https://learn.microsoft.com/zh-tw/lifecycle/products/windows-server-2016?WT.mc_id=DOP-MVP-37580">2027-01-12 才 EOS</a>，2019 則是 <a href="https://learn.microsoft.com/zh-tw/lifecycle/products/windows-server-2019?WT.mc_id=DOP-MVP-37580">2029-01-09</a>，因此若程式會部署到 Window Server 2022 之前的伺服器，就必須留意作業系統不支援的問題。</p> <p>評估之後，若沒有 Arm64 及 Windows Form/WPF 無障礙需求，.NET 4.8 應是相容性更高的好選擇，結案。</p> <p data-slug="netfx-48-or-481" data-title-en="Should I choose .NET 4.8.1 or 4.8?" data-catg=".NET" data-fbimg="https://cdn.pixabay.com/photo/2018/04/11/08/59/rails-3309912_1280.jpg#1280#720">Choose .NET Framework 4.8 over 4.8.1 for broader OS compatibility unless Arm64 or accessibility features are required; support aligns with Windows lifecycle.</p>]]>
    </description>
    <content:encoded><![CDATA[<p>安裝 Visual Studio 時，我們可以選擇要安裝哪些版本 .NET Framework ：</p> <p><img src="https://blog.darkthread.net/Posts/files/2025/Fig1_638955276014073226.png"></p> <p>註：SDK 與目標套件差在哪裡？SDK 包含編譯器整合、設計工具、參考組件、專案範本與建置支援，必須要安裝才能在 Visual Studio 建立及編輯該版本的 .NET Framework 應用程式專案(例如 WinForms/WPF)；至於目標套件(Targeting Pack) 僅包含特定 .NET Framework 版本的參考組件與目標檔案，讓專案可以將 Target Framework 設為該版本並成功編譯，不提供設計工具與額外範本。<a href="https://learn.microsoft.com/en-us/dotnet/framework/install/guide-for-developers?WT.mc_id=DOP-MVP-37580#to-install-the-net-framework-developer-pack-or-targeting-pack">參考</a></p> <p>在 .NET Framework 專案設定視窗，我們可以選擇編譯成有安裝目標套件的 .NET Framework 版本。</p> <p><img src="https://blog.darkthread.net/Posts/files/2025/Fig2_638955276015786136.png"></p> <p>補充隱藏觀念：.NET 4.X 採「就地更新」(In-Place Update)政策，.NET 4.X 安裝時會覆寫換掉 \Windows.NET Framework\V4.0.30319 的 .NET 4 舊版 dll，沿用相同目錄同樣檔名但置換成新版本。故安裝 .NET 4.8 後， 以 .NET 4.0、4.5、4.6、4.7、4.8 為目標編譯的程式都是使用 .NET 4.8 版的 Runtime，選取 Target Framework 可讓程式執行時向下相容，模擬舊版本行為。 延伸閱讀：<a href="/blog/ref-higher-netfx-ver-dll/">.NET 4.6 專案可以參照及使用 .NET 4.8 編譯的程式庫嗎？</a>、<a href="/blog/httruntime-targetframework/">認識 web.config compilation 與 httpRuntime 的 targetFramework</a></p> <p>針對 .NET Framework 專案，我們可以選擇編譯成 .NET 4.6.2、.NET 4.7.2、...、.NET 4.8、.NET 4.8.1，依據新版會修掉一些 Bug、版本愈新可以用愈久(愈晚面對 EOS)... 等慣例，所以我們該義無反顧選 .NET 4.8.1？</p> <p>錯!</p> <p>依據 <a href="https://learn.microsoft.com/zh-tw/lifecycle/faq/dotnet-framework?WT.mc_id=DOP-MVP-37580#-----net-framework---------------">官方文件</a>，.NET 4.8 將以 Windows 元件形式提供，其支援週期與 Windows 看齊，也就是 Windows 用多久，.NET 4.8 就能用多久，不須擔心提早 EOS。而微軟也建議客戶升級至 .NET Framework 4.8 以獲得最高層級的效能、可靠性和安全性。(依據 Windows Server 2025 內建 .NET 4.8.1 推算，.NET Framework 4.8 至少能再戰個十年以上吧)</p> <p>微軟在 2019-04-18 推出 .NET 4.8，.NET Framework 發展就封頂了，.NET 路線改較由 .NET 5/6/7/8... 傳承下去。兩年多後 (2022-08-09) 推出的 .NET 4.8.1 只做了很微小的強化，主要是加入對 Arm64 CPU 的支援、強化 Windows Forms/ WPF 的 WCGA2.1 無障礙標準支援，應用程式未必會用到。但 4.8.1 較大的問題是一些舊版作業系統不支援，像是 Windows 7 SP1、Windows 8.1、Windows 10 2004/1909/1903、Windows Server 2019/2016/2012 R2/2012... 等。其中 Windows Server 2016 到 <a href="https://learn.microsoft.com/zh-tw/lifecycle/products/windows-server-2016?WT.mc_id=DOP-MVP-37580">2027-01-12 才 EOS</a>，2019 則是 <a href="https://learn.microsoft.com/zh-tw/lifecycle/products/windows-server-2019?WT.mc_id=DOP-MVP-37580">2029-01-09</a>，因此若程式會部署到 Window Server 2022 之前的伺服器，就必須留意作業系統不支援的問題。</p> <p>評估之後，若沒有 Arm64 及 Windows Form/WPF 無障礙需求，.NET 4.8 應是相容性更高的好選擇，結案。</p> <p data-slug="netfx-48-or-481" data-title-en="Should I choose .NET 4.8.1 or 4.8?" data-catg=".NET" data-fbimg="https://cdn.pixabay.com/photo/2018/04/11/08/59/rails-3309912_1280.jpg#1280#720">Choose .NET Framework 4.8 over 4.8.1 for broader OS compatibility unless Arm64 or accessibility features are required; support aligns with Windows lifecycle.</p>]]></content:encoded>
    <itunes:image href="https://blog.darkthread.net/Posts/files/2025/Fig1_638955276014073226.png"/>
          <media:content url="https://blog.darkthread.net/Posts/files/2025/Fig1_638955276014073226.png" medium="image"/>
    <pubDate>Wed, 08 Oct 2025 13:31:10 GMT</pubDate>
  </item></channel>
</rss>